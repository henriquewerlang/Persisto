unit Delphi.ORM.Query.Builder.Test;

interface

uses System.Rtti, DUnitX.TestFramework, Delphi.ORM.Query.Builder, Delphi.ORM.Database.Connection, Delphi.ORM.Attributes, Delphi.ORM.Query.Builder.Test.Entity;

type
  [TestFixture]
  TDelphiORMQueryBuilderTest = class
  public
    [SetupFixture]
    procedure Setup;
    [Test]
    procedure IfNoCommandCalledTheSQLMustReturnEmpty;
    [Test]
    procedure WhenCallSelectCommandTheSQLMustReturnTheWordSelect;
    [Test]
    procedure IfNoCommandIsCalledCantRaiseAnExceptionOfAccessViolation;
    [Test]
    procedure WhenSelectAllFieldsFromAClassMustPutAllThenInTheResultingSQL;
    [Test]
    procedure IfTheAllFieldNoCalledCantRaiseAnExceptionOfAccessViolation;
    [Test]
    procedure OnlyPublishedPropertiesCanAppearInSQL;
    [Test]
    procedure WhenCallOpenProcedureMustOpenTheDatabaseCursor;
    [Test]
    procedure WhenOpenOneMustFillTheClassWithTheValuesOfCursor;
    [Test]
    procedure WhenAFilterConditionMustBuildTheSQLAsExpected;
    [Test]
    procedure IfNotExistsAFilterInWhereMustReturnTheQueryWithoutWhereCommand;
    [Test]
    procedure WhenCallInsertProcedureMustBuildTheSQLWithAllFieldsAndValuesFromTheClassParameter;
    [Test]
    procedure OnlyPublishedPropertiesMustAppearInInsertSQL;
    [Test]
    procedure OnlyPublishedPropertiesMustAppearInUpdateSQL;
    [Test]
    procedure WhenCallUpdateMustBuildTheSQLWithAllPropertiesInTheObjectParameter;
    [Test]
    procedure WhenTheClassHaveThePrimaryKeyAttributeMustBuildTheWhereWithTheValuesOfFieldInTheKeyList;
    [Test]
    procedure TheKeyFieldCantBeUpdatedInTheUpdateProcedure;
    [Test]
    procedure WhenTheClassDontHaveThePrimaryKeyAttributeCantRaiseAException;
    [Test]
    procedure WhenCallTheDeleteProcedureMustBuildTheSQLWithTheValuesOfKeysOfClass;
    [Test]
    procedure WhenTheClassDontHaveAnyPrimaryKeyTheDeleteMustBuildTheSQLWithoutWhereCondition;
    [Test]
    procedure TheClassBeingSelectedMustHaveTheAliasDefined;
    [Test]
    procedure TheFieldsHaveToBeGeneratedWithTheAliasOfTheRespectiveTables;
    [Test]
    procedure WhenClassHasOtherClassesLinkedToItYouHaveToGenerateTheJoinBetweenThem;
    [Test]
    procedure AllTheDirectForeignKeyMustBeGeneratedInTheResultingSQL;
    [Test]
    procedure TheForeignKeyMustBeLoadedRecursive;
    [Test]
    procedure WhenTheClassHaveForeignKeysThatsLoadsRecursivelyCantRaiseAnError;
    [Test]
    procedure MustGenerateTheSQLFollowingTheHierarchyAsSpected;
    [Test]
    procedure WhenConfiguredTheRecursivityLevelTheJoinsMustFollowTheConfiguration;
    [Test]
    procedure WhenTheClassRecursivelyItselfMoreThenOneTimeMustBuildTheSQLAsEspected;
    [Test]
    procedure WhenTheClassHaveManyValueAssociationMustLoadTheJoinBetweenTheParentAndChildTable;
    [Test]
    procedure TheManyValueAssociationMustAvoidRecursivilyLoadTheParentClassWhenLoadingTheChildClass;
    [Test]
    procedure WhenIsLoadedAJoinMustLoadTheFieldThatIsTheLinkBetweenTheClasses;
    [Test]
    procedure TheManyValueAssociationMustLoadTheLinkingFieldBetweenTheClasses;
    [Test]
    procedure WhenGetAllFieldsOfATableMustPutThePrimaryKeyFieldInTheBeginningOfTheResultingArray;
    [Test]
    procedure WhenAFieldIsMarkedWithAutoGeneratedItCantBeInTheInsertSQL;
    [Test]
    procedure WhenInsertAClassWithTheAutoGeneratedAttributeMustLoadTheFieldNamesInTheArrayOfTheProcedure;
    [Test]
    procedure TheValuesReturnedInTheCursorOfTheInsertMustLoadTheFieldsOfTheClassBeenInserted;
    [Test]
    procedure WhenDontHaveAResultingCursorCantLoadTheProperties;
    [Test]
    procedure WhenInsertingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheInsert;
    [Test]
    procedure WhenUpdatingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheUpdateList;
    [Test]
    procedure ThenForeignKeyLinkOfAnManyValueAssociationCantAppearInTheSQL;
    [Test]
    procedure WhenTheClassAsAFieldWithNullableRecordMustInsertTheValueNullInSQLIfIsNull;
    [Test]
    procedure WhenTheClassAsAFieldWithNullableRecordMustInsertThenValueOfThePropertyIfNotIsNull;
    [Test]
    procedure WhenTheClassAsAFieldWithNullableRecordMustUpdateTheValueNullInSQLIfIsNull;
    [Test]
    procedure WhenTheClassAsAFieldWithNullableRecordMustUpdateThenValueOfThePropertyIfNotIsNull;
  end;

  [TestFixture]
  TQueryBuilderSelectTest = class
  public
    [SetupFixture]
    procedure Setup;
    [Test]
    procedure WhenIsNotDefinedTheRecursivityLevelMustBeOneTheDefaultValue;
    [Test]
    procedure WhenTheClassHaveForeignKeyMustBuildTheSQLWithTheAliasOfTheJoinMapped;
  end;

  [TestFixture]
  TQueryBuilderComparisonTest = class
  public
    [SetupFixture]
    procedure Setup;
    [Test]
    procedure WhenCallTheFieldFuncitionMustLoadTheFieldNameInTheLeftOperator;
    [Test]
    procedure WhenCompareTheFieldWithAStringValueMustLoadTheComparisonAsExpected;
    [Test]
    procedure WhenCompareTheFieldWithAnIntegerValueMustLoadTheComparisonAsExpected;
    [Test]
    procedure WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithFilledComparisons;
    [Test]
    procedure WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithOperationAndFilled;
    [Test]
    procedure WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithFilledComparisons;
    [Test]
    procedure WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithOperationOrFilled;
  end;

  [TestFixture]
  TQueryBuilderLogicalOperationTest = class
  public
    [Test]
    procedure WhenTheAndOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
    [Test]
    procedure WhenTheOrOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
    [Test]
    procedure WhenAndOperatorMustLoadTheOperationWithTheAndValue;
    [Test]
    procedure WhenOrOperatorMustLoadTheOperationWithTheOrValue;
    [Test]
    procedure WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationAnd;
    [Test]
    procedure WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationOr;
    [Test]
    procedure WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheAndOperation;
    [Test]
    procedure WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheOrOperation;
    [Test]
    procedure WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheAndOperation;
    [Test]
    procedure WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheOrOperation;
    [Test]
    procedure WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInAndOperator;
    [Test]
    procedure WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInOrOperator;
  end;

  [TestFixture]
  TQueryBuilderAllFieldsTest = class
  public
    [SetupFixture]
    procedure Setup;
    [Test]
    procedure InASingleClassMustLoadAllFieldsFromThatClass;
    [Test]
    procedure WhenTheClassHaveForeignKeyMustLoadAllFieldsOfAllClassesInvolved;
    [Test]
    procedure FieldsOfAnObjectCantBeLoadedInTheListOfFields;
    [Test]
    procedure TheFieldsMustBeLoadedRecursivelyInAllForeignKeys;
    [Test]
    procedure WhenTheClassIsRecursiveItselfCantRaiseAnErrorInTheExecution;
    [Test]
    procedure TheRecursivelyMustBeRespectedAndLoadAllFieldFromTheClasses;
    [Test]
    procedure WhenThePropertyIsAnArrayCantLoadTheFieldInTheList;
  end;

  [TestFixture]
  TQueryBuilderWhereTest = class
  public
    [SetupFixture]
    procedure Setup;
    [Test]
    procedure WhenCompareAFieldWithAnValueMustBuildTheFilterAsExpected;
    [Test]
    procedure ASimpleLogicalAndOperationMustBeGeneratedAsExpected;
    [Test]
    procedure ASimpleLogicalOrOperationMustBeGeneratedAsExpected;
    [Test]
    procedure AComposeLogicalOperationMustBeGeneratedAsExpected;
    [Test]
    procedure WhenLeftOperationIsASimpleComparisonAndRightIsALogicalOperationItHasToGenerateSQLAsExpected;
    [Test]
    procedure WhenBothOperationsAreLogicalHaveToGenerateSQLAsExpected;
    [TestCase('Between', 'qbcoBetween')]
    [TestCase('None', 'qbcoNone')]
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    [TestCase('Null', 'qbcoNull')]
    [TestCase('Not Null', 'qbcoNotNull')]
    procedure TheComparisonOperatorsMustBeGeneratedAsExpected(Operation: TQueryBuilderComparisonOperator);
    [Test]
    procedure IfTheWhereDontFoundTheFieldMustRaiseAnError;
    [Test]
    procedure WhenExistsAJoinLoadedMustPutTheAliasOfTheTableBeforeTheFieldName;
    [Test]
    procedure WhenUsingAComposeNameMustPutTheAliasOfTheTableBeforeTheFieldName;
    [Test]
    procedure WhenUsingComposeFieldNameInAOperationWithoutFromMustRaiseAnError;
    [TestCase('AnsiChar', 'AnsiChar,''C''')]
    [TestCase('AnsiString', 'AnsiString,''AnsiString''')]
    [TestCase('Char', 'Char,''C''')]
    [TestCase('Class', 'Class,1234')]
    [TestCase('Enumerator', 'Enumerator,1')]
    [TestCase('Empty class', 'EmptyClass,null')]
    [TestCase('Float', 'Float,1234.456')]
    [TestCase('Date', 'Date,''2020-01-31''')]
    [TestCase('DateTime', 'DateTime,''2020-01-31 12:34:56''')]
    [TestCase('GUID', 'GUID,''{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}''')]
    [TestCase('Integer', 'Integer,1234')]
    [TestCase('Int64', 'Int64,1234')]
    [TestCase('String', 'String,''String''')]
    [TestCase('Time', 'Time,''12:34:56''')]
    procedure TheComparisonOfTheValuesMustOccurAsExpected(TypeToConvert, ValueToCompare: String);
    [Test]
    procedure TheLasNameInTheComposeNameMustBeTheFieldToBeFoundInAClass;
    [TestCase('Between', 'qbcoBetween')]
    [TestCase('None', 'qbcoNone')]
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    [TestCase('Null', 'qbcoNull')]
    [TestCase('Not Null', 'qbcoNotNull')]
    procedure WhenComparingFieldMustBuildTheFilterAsExpected(Operation: TQueryBuilderComparisonOperator);
  end;

  TDatabaseTest = class(TInterfacedObject, IDatabaseConnection)
  private
    FCursor: IDatabaseCursor;
    FSQL: String;
    FOutputFields: TArray<String>;

    function ExecuteInsert(SQL: String; OutputFields: TArray<String>): IDatabaseCursor;
    function OpenCursor(SQL: String): IDatabaseCursor;

    procedure ExecuteDirect(SQL: String);
  public
    constructor Create(Cursor: IDatabaseCursor);

    property SQL: String read FSQL;
    property OutputFields: TArray<String> read FOutputFields;
  end;

  TMyEnum = (Enum1, Enum2, Enum3);

implementation

uses System.SysUtils, System.DateUtils, Delphi.ORM.Mapper, Delphi.ORM.Cursor.Mock, Delphi.ORM.Nullable;

{ TDelphiORMQueryBuilderTest }

procedure TDelphiORMQueryBuilderTest.AllTheDirectForeignKeyMustBeGeneratedInTheResultingSQL;
begin
  var Query := TQueryBuilderFrom.Create(nil, 1);

  Query.From<TClassWithTwoForeignKey>;

  Assert.AreEqual(' from ClassWithTwoForeignKey T1 left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id left join ClassWithPrimaryKey T3 on T1.IdAnotherClass2=T3.Id', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.IfNoCommandCalledTheSQLMustReturnEmpty;
begin
  var Query := TQueryBuilder.Create(nil);

  Assert.AreEqual(EmptyStr, Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.IfNoCommandIsCalledCantRaiseAnExceptionOfAccessViolation;
begin
  var Query := TQueryBuilder.Create(nil);

  Assert.WillNotRaise(
    procedure
    begin
      Query.GetSQL
    end, EAccessViolation);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.IfNotExistsAFilterInWhereMustReturnTheQueryWithoutWhereCommand;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  Query.Select.All.From<TMyTestClass>.Open;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Database.SQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.IfTheAllFieldNoCalledCantRaiseAnExceptionOfAccessViolation;
begin
  var Query := TQueryBuilder.Create(nil);

  Query.Select;

  Assert.WillNotRaise(
    procedure
    begin
      Query.GetSQL;
    end, EAccessViolation);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.MustGenerateTheSQLFollowingTheHierarchyAsSpected;
begin
  var Query := TQueryBuilderFrom.Create(nil, 1);

  Query.From<TClassHierarchy1>;

  Assert.AreEqual(
        ' from ClassHierarchy1 T1 ' +
    'left join ClassHierarchy2 T2 ' +
           'on T1.IdClass1=T2.Id ' +
    'left join ClassHierarchy1 T3 ' +
           'on T2.IdClass3=T3.Id ' +
    'left join ClassHierarchy3 T4 ' +
           'on T3.IdClass2=T4.Id ' +
    'left join ClassHierarchy1 T5 ' +
           'on T2.IdClass4=T5.Id ' +
    'left join ClassHierarchy3 T6 ' +
           'on T5.IdClass2=T6.Id ' +
    'left join ClassHierarchy3 T7 ' +
           'on T1.IdClass2=T7.Id', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.OnlyPublishedPropertiesMustAppearInInsertSQL;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TClassOnlyPublic.Create;
  MyClass.Name := 'My name';
  MyClass.Value := 222;

  Query.Insert(MyClass);

  Assert.AreEqual('insert into ClassOnlyPublic()values()', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.OnlyPublishedPropertiesMustAppearInUpdateSQL;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);
  var SQL := 'update ClassOnlyPublic set ';

  var MyClass := TClassOnlyPublic.Create;
  MyClass.Name := 'My name';
  MyClass.Value := 222;

  Query.Update(MyClass);

  Assert.AreEqual(SQL, Database.SQL.Substring(0, SQL.Length));

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.Setup;
begin
  TMapper.Default.LoadAll;
end;

procedure TDelphiORMQueryBuilderTest.TheClassBeingSelectedMustHaveTheAliasDefined;
begin
  var Query := TQueryBuilderFrom.Create(nil, 1);

  Query.From<TMyTestClass>;

  Assert.AreEqual(' from MyTestClass T1', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.TheFieldsHaveToBeGeneratedWithTheAliasOfTheRespectiveTables;
begin
  var Query := TQueryBuilder.Create(nil);

  Query.Select.All.From<TMyTestClass>;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.TheForeignKeyMustBeLoadedRecursive;
begin
  var Query := TQueryBuilderFrom.Create(nil, 1);

  Query.From<TClassWithForeignKeyRecursive>;

  Assert.AreEqual(' from ClassWithForeignKeyRecursive T1 left join ClassWithForeignKey T2 on T1.IdAnotherClass=T2.Id left join ClassWithPrimaryKey T3 on T2.IdAnotherClass=T3.Id', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.TheKeyFieldCantBeUpdatedInTheUpdateProcedure;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);
  var SQL := 'update ClassWithPrimaryKeyAttribute set Id=123,Value=222';

  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id := 123;
  MyClass.Id2 := 456;
  MyClass.Value := 222;

  Query.Update(MyClass);

  Assert.AreEqual(SQL, Database.SQL.Substring(0, SQL.Length));

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.TheManyValueAssociationMustAvoidRecursivilyLoadTheParentClassWhenLoadingTheChildClass;
begin
  var From := TQueryBuilderFrom.Create(nil, 5);

  From.From<TMyEntityWithManyValueAssociation>;

  Assert.AreEqual(
        ' from MyEntityWithManyValueAssociation T1 ' +
    'left join MyEntityWithManyValueAssociationChild T2 ' +
           'on T1.Id=T2.IdManyValueAssociation',
    From.GetSQL);

  From.Free;
end;

procedure TDelphiORMQueryBuilderTest.TheManyValueAssociationMustLoadTheLinkingFieldBetweenTheClasses;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  From.From<TMyEntityWithManyValueAssociation>;

  Assert.IsNotNull(From.Join.Links[0].Field);

  From.Free;
end;

procedure TDelphiORMQueryBuilderTest.ThenForeignKeyLinkOfAnManyValueAssociationCantAppearInTheSQL;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  From.From<TManyValueAssociationParent>;

  Assert.AreEqual(
        ' from ManyValueAssociationParent T1 ' +
    'left join ManyValueAssociationWithThreeForeignKey T2 ' +
           'on T1.Id=T2.IdManyValueAssociationParent ' +
    'left join ManyValueAssociationParent T3 ' +
           'on T2.IdForeingKeyOne=T3.Id ' +
    'left join ManyValueAssociationParent T4 ' +
           'on T2.IdForeingKeyTwo=T4.Id',
    From.GetSQL);

  From.Free;
end;

procedure TDelphiORMQueryBuilderTest.TheValuesReturnedInTheCursorOfTheInsertMustLoadTheFieldsOfTheClassBeenInserted;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create([[123, 'My value']]));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  Query.Insert(MyClass);

  Assert.AreEqual(123, MyClass.Id);
  Assert.AreEqual('My value', MyClass.AnotherField);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.OnlyPublishedPropertiesCanAppearInSQL;
begin
  var Query := TQueryBuilder.Create(nil);

  Query.Select.All.From<TMyTestClass>;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenAFieldIsMarkedWithAutoGeneratedItCantBeInTheInsertSQL;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  Query.Insert(MyClass);

  Assert.AreEqual('insert into AutoGeneratedClass(Value)values(''abc'')', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenAFilterConditionMustBuildTheSQLAsExpected;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  Query.Select.All.From<TMyTestClass>.Where(Field('Field') = 1234).Open;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1 where T1.Field=1234', Database.SQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenCallInsertProcedureMustBuildTheSQLWithAllFieldsAndValuesFromTheClassParameter;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TMyTestClass.Create;
  MyClass.Field := 123;
  MyClass.Name := 'My name';
  MyClass.Value := 222.333;

  Query.Insert(MyClass);

  Assert.AreEqual('insert into MyTestClass(Field,Name,Value)values(123,''My name'',222.333)', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenCallOpenProcedureMustOpenTheDatabaseCursor;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  Query.Select.All.From<TMyTestClass>.Open;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Database.SQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenCallSelectCommandTheSQLMustReturnTheWordSelect;
begin
  var Query := TQueryBuilder.Create(nil);

  Query.Select;

  Assert.AreEqual('select ', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenCallTheDeleteProcedureMustBuildTheSQLWithTheValuesOfKeysOfClass;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id2 := 456;

  Query.Delete(MyClass);

  Assert.AreEqual('delete from ClassWithPrimaryKeyAttribute where Id2=456', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenCallUpdateMustBuildTheSQLWithAllPropertiesInTheObjectParameter;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TMyTestClass.Create;
  MyClass.Field := 123;
  MyClass.Name := 'My name';
  MyClass.Value := 222.333;

  Query.Update(MyClass);

  Assert.AreEqual('update MyTestClass set Field=123,Name=''My name'',Value=222.333', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenClassHasOtherClassesLinkedToItYouHaveToGenerateTheJoinBetweenThem;
begin
  var Query := TQueryBuilderFrom.Create(nil, 1);

  Query.From<TClassWithForeignKey>;

  Assert.AreEqual(' from ClassWithForeignKey T1 left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenConfiguredTheRecursivityLevelTheJoinsMustFollowTheConfiguration;
begin
  var Query := TQueryBuilder.Create(nil);

  var From := Query.Select.RecursivityLevel(3).All;

  From.From<TClassRecursiveFirst>;

  Assert.AreEqual(
            ' from ClassRecursiveFirst T1 ' +
        'left join ClassRecursiveThrid T2 ' +
               'on T1.IdRecursive=T2.Id ' +
        'left join ClassRecursiveSecond T3 ' +
               'on T2.IdRecursive=T3.Id ' +
        'left join ClassRecursiveFirst T4 ' +
               'on T3.IdRecursive=T4.Id ' +
        'left join ClassRecursiveThrid T5 ' +
               'on T4.IdRecursive=T5.Id ' +
        'left join ClassRecursiveSecond T6 ' +
               'on T5.IdRecursive=T6.Id ' +
        'left join ClassRecursiveFirst T7 ' +
               'on T6.IdRecursive=T7.Id ' +
        'left join ClassRecursiveThrid T8 ' +
               'on T7.IdRecursive=T8.Id ' +
        'left join ClassRecursiveSecond T9 ' +
               'on T8.IdRecursive=T9.Id ' +
        'left join ClassRecursiveFirst T10 ' +
               'on T9.IdRecursive=T10.Id',
    From.GetSQL);

  Query.GetSQL;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenDontHaveAResultingCursorCantLoadTheProperties;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  Query.Insert(MyClass);

  Assert.AreEqual(0, MyClass.Id);
  Assert.AreEqual(EmptyStr, MyClass.AnotherField);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenGetAllFieldsOfATableMustPutThePrimaryKeyFieldInTheBeginningOfTheResultingArray;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  var Fields := TQueryBuilderAllFields.Create(From);

  From.From<TMyEntityWithPrimaryKeyInLastField>;

  Assert.IsTrue(Fields.GetFields[0].Field.InPrimaryKey);

  From.Free;

  Fields.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenInsertAClassWithTheAutoGeneratedAttributeMustLoadTheFieldNamesInTheArrayOfTheProcedure;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create([[123, 'My value']]));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  Query.Insert(MyClass);

  Assert.AreEqual('Id', Database.OutputFields[0]);
  Assert.AreEqual('AnotherField', Database.OutputFields[1]);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenInsertingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheInsert;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TMyEntityWithManyValueAssociation.Create;
  MyClass.Id := 12345;

  Query.Insert(MyClass);

  Assert.AreEqual('insert into MyEntityWithManyValueAssociation(Id)values(12345)', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenIsLoadedAJoinMustLoadTheFieldThatIsTheLinkBetweenTheClasses;
begin
  var Query := TQueryBuilderFrom.Create(nil, 1);

  Query.From<TClassWithForeignKey>;

  Assert.IsNotNull(Query.Join.Links[0].Field);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenOpenOneMustFillTheClassWithTheValuesOfCursor;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create([[123, 'My name', 123.456]]));
  var Query := TQueryBuilder.Create(Database);

  var Result := Query.Select.All.From<TMyTestClass>.Open.One;

  Assert.AreEqual(123, Result.Field);

  Assert.AreEqual('My name', Result.Name);

  Assert.AreEqual<Double>(123.456, Result.Value);

  Result.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenSelectAllFieldsFromAClassMustPutAllThenInTheResultingSQL;
begin
  var Query := TQueryBuilder.Create(nil);

  Query.Select.All.From<TMyTestClass>;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Query.GetSQL);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassAsAFieldWithNullableRecordMustInsertThenValueOfThePropertyIfNotIsNull;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Nullable := 1234;

  Query.Insert(MyClass);

  Assert.AreEqual('insert into ClassWithNullableProperty(Id,Nullable)values(0,1234)', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassAsAFieldWithNullableRecordMustInsertTheValueNullInSQLIfIsNull;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TClassWithNullableProperty.Create;

  Query.Insert(MyClass);

  Assert.AreEqual('insert into ClassWithNullableProperty(Id,Nullable)values(0,null)', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassAsAFieldWithNullableRecordMustUpdateThenValueOfThePropertyIfNotIsNull;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Id := 123;
  MyClass.Nullable := 456;

  Query.Update(MyClass);

  Assert.AreEqual('update ClassWithNullableProperty set Nullable=456 where Id=123', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassAsAFieldWithNullableRecordMustUpdateTheValueNullInSQLIfIsNull;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Id := 123;

  Query.Update(MyClass);

  Assert.AreEqual('update ClassWithNullableProperty set Nullable=null where Id=123', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassDontHaveAnyPrimaryKeyTheDeleteMustBuildTheSQLWithoutWhereCondition;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TMyTestClass.Create;

  Query.Delete(MyClass);

  Assert.AreEqual('delete from MyTestClass', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassDontHaveThePrimaryKeyAttributeCantRaiseAException;
begin
  var Database := TDatabaseTest.Create(nil);
  var MyClass := TClassOnlyPublic.Create;
  var Query := TQueryBuilder.Create(Database);

  Assert.WillNotRaise(
    procedure
    begin
      Query.Update(MyClass);
    end, EAccessViolation);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassHaveForeignKeysThatsLoadsRecursivelyCantRaiseAnError;
begin
  var Query := TQueryBuilderFrom.Create(nil, 1);

  Assert.WillNotRaise(
    procedure
    begin
      Query.From<TClassRecursiveFirst>;

      Query.GetSQL;
    end);

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassHaveManyValueAssociationMustLoadTheJoinBetweenTheParentAndChildTable;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  From.From<TMyEntityWithManyValueAssociation>;

  Assert.AreEqual(
        ' from MyEntityWithManyValueAssociation T1 ' +
    'left join MyEntityWithManyValueAssociationChild T2 ' +
           'on T1.Id=T2.IdManyValueAssociation',
    From.GetSQL);

  From.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassHaveThePrimaryKeyAttributeMustBuildTheWhereWithTheValuesOfFieldInTheKeyList;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id := 123;
  MyClass.Id2 := 456;
  MyClass.Value := 222;

  Query.Update(MyClass);

  Assert.AreEqual('update ClassWithPrimaryKeyAttribute set Id=123,Value=222 where Id2=456', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenTheClassRecursivelyItselfMoreThenOneTimeMustBuildTheSQLAsEspected;
begin
  var From := TQueryBuilderFrom.Create(nil, 2);

  From.From<TClassRecursiveItself>;

  Assert.AreEqual(
        ' from ClassRecursiveItself T1 ' +
    'left join ClassRecursiveItself T2 ' +
           'on T1.IdRecursive1=T2.Id ' +
    'left join ClassRecursiveItself T3 ' +
           'on T2.IdRecursive1=T3.Id ' +
    'left join ClassRecursiveItself T4 ' +
           'on T2.IdRecursive2=T4.Id ' +
    'left join ClassRecursiveItself T5 ' +
           'on T1.IdRecursive2=T5.Id ' +
    'left join ClassRecursiveItself T6 ' +
           'on T5.IdRecursive1=T6.Id ' +
    'left join ClassRecursiveItself T7 ' +
           'on T5.IdRecursive2=T7.Id',
    From.GetSQL);

  From.Free;
end;

procedure TDelphiORMQueryBuilderTest.WhenUpdatingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheUpdateList;
begin
  var Database := TDatabaseTest.Create(TCursorMock.Create(nil));
  var Query := TQueryBuilder.Create(Database);

  var MyClass := TMyEntityWithManyValueAssociation.Create;
  MyClass.Id := 12345;

  Query.Update(MyClass);

  Assert.AreEqual('update MyEntityWithManyValueAssociation set  where Id=12345', Database.SQL);

  MyClass.Free;

  Query.Free;
end;

{ TDatabaseTest }

constructor TDatabaseTest.Create(Cursor: IDatabaseCursor);
begin
  inherited Create;

  FCursor := Cursor;
end;

procedure TDatabaseTest.ExecuteDirect(SQL: String);
begin
  FSQL := SQL;
end;

function TDatabaseTest.ExecuteInsert(SQL: String; OutputFields: TArray<String>): IDatabaseCursor;
begin
  FOutputFields := OutputFields;
  Result := OpenCursor(SQL);
end;

function TDatabaseTest.OpenCursor(SQL: String): IDatabaseCursor;
begin
  FSQL := SQL;
  Result := FCursor;
end;

{ TQueryBuilderAllFieldsTest }

procedure TQueryBuilderAllFieldsTest.FieldsOfAnObjectCantBeLoadedInTheListOfFields;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  var FieldList := TQueryBuilderAllFields.Create(From);

  From.From<TClassWithTwoForeignKey>;

  for var Field in FieldList.GetFields do
    Assert.IsFalse(Field.Field.TypeInfo.PropertyType.InheritsFrom(TRttiStructuredType));

  From.Free;

  FieldList.Free;
end;

procedure TQueryBuilderAllFieldsTest.InASingleClassMustLoadAllFieldsFromThatClass;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  var FieldList := TQueryBuilderAllFields.Create(From);

  From.From<TMyTestClass>;

  Assert.AreEqual<Integer>(3, Length(FieldList.GetFields));

  From.Free;

  FieldList.Free;
end;

procedure TQueryBuilderAllFieldsTest.Setup;
begin
  TMapper.Default.LoadAll;
end;

procedure TQueryBuilderAllFieldsTest.TheFieldsMustBeLoadedRecursivelyInAllForeignKeys;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  var FieldList := TQueryBuilderAllFields.Create(From);

  From.From<TClassWithForeignKeyRecursive>;

  Assert.AreEqual<Integer>(4, Length(FieldList.GetFields));

  From.Free;

  FieldList.Free;
end;

procedure TQueryBuilderAllFieldsTest.TheRecursivelyMustBeRespectedAndLoadAllFieldFromTheClasses;
begin
  var From := TQueryBuilderFrom.Create(nil, 3);

  var FieldList := TQueryBuilderAllFields.Create(From);

  From.From<TClassRecursiveFirst>;

  Assert.AreEqual<Integer>(10, Length(FieldList.GetFields));

  From.Free;

  FieldList.Free;
end;

procedure TQueryBuilderAllFieldsTest.WhenTheClassHaveForeignKeyMustLoadAllFieldsOfAllClassesInvolved;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  var FieldList := TQueryBuilderAllFields.Create(From);

  From.From<TClassWithTwoForeignKey>;

  Assert.AreEqual<Integer>(5, Length(FieldList.GetFields));

  From.Free;

  FieldList.Free;
end;

procedure TQueryBuilderAllFieldsTest.WhenTheClassIsRecursiveItselfCantRaiseAnErrorInTheExecution;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  var FieldList := TQueryBuilderAllFields.Create(From);

  From.From<TClassRecursiveFirst>;

  Assert.WillNotRaise(
    procedure
    begin
      FieldList.GetFields;
    end);

  From.Free;

  FieldList.Free;
end;

procedure TQueryBuilderAllFieldsTest.WhenThePropertyIsAnArrayCantLoadTheFieldInTheList;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);

  var FieldList := TQueryBuilderAllFields.Create(From);

  From.From<TMyEntityWithManyValueAssociation>;

  Assert.AreEqual<Integer>(2, Length(FieldList.GetFields));

  From.Free;

  FieldList.Free;
end;

{ TQueryBuilderSelectTest }

procedure TQueryBuilderSelectTest.Setup;
begin
  TMapper.Default.LoadAll;
end;

procedure TQueryBuilderSelectTest.WhenIsNotDefinedTheRecursivityLevelMustBeOneTheDefaultValue;
begin
  var Select := TQueryBuilderSelect.Create(nil);

  Assert.AreEqual(1, Select.RecursivityLevelValue);

  Select.Free;
end;

procedure TQueryBuilderSelectTest.WhenTheClassHaveForeignKeyMustBuildTheSQLWithTheAliasOfTheJoinMapped;
begin
  var Database := TDatabaseTest.Create(nil);
  var Query := TQueryBuilder.Create(Database);

  Query.Select.All.From<TClassWithForeignKey>.Open;

  Assert.AreEqual('select T1.Id F1,T2.Id F2,T2.Value F3 from ClassWithForeignKey T1 left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id', Database.SQL);

  Query.Free;
end;

{ TQueryBuilderComparisonTest }

procedure TQueryBuilderComparisonTest.Setup;
begin
  TMapper.Default.LoadAll;
end;

procedure TQueryBuilderComparisonTest.WhenCallTheFieldFuncitionMustLoadTheFieldNameInTheLeftOperator;
begin
  var Comparison := Field('MyField');

  Assert.AreEqual('MyField', Comparison.Value.Comparison.Left.FieldNames[0]);

  Comparison.Value.Free;
end;

procedure TQueryBuilderComparisonTest.WhenCompareTheFieldWithAnIntegerValueMustLoadTheComparisonAsExpected;
begin
  var Value := 1234;

  for var Operation := Low(TQueryBuilderComparisonOperator) to High(TQueryBuilderComparisonOperator) do
  begin
    var Comparison: TQueryBuilderComparisonRecord;
    var Field := Field('MyField');

    case Operation of
      qbcoEqual: Comparison := Field = Value;
      qbcoGreaterThan: Comparison := Field > Value;
      qbcoGreaterThanOrEqual: Comparison := Field >= Value;
      qbcoLessThan: Comparison := Field < Value;
      qbcoLessThanOrEqual: Comparison := Field <= Value;
      qbcoNone, qbcoNull, qbcoNotNull, qbcoBetween:
      begin
        Field.Value.Free;

        Continue;
      end;
      qbcoNotEqual: Comparison := Field <> Value;
      else raise Exception.Create('Not implemented');
    end;

    var Left := Comparison.Value.Comparison;

    Assert.AreEqual('MyField', Left.Left.FieldNames[0]);
    Assert.AreEqual(Operation, Left.Operation);
    Assert.AreEqual(Value, Left.Right.Value.AsInteger);

    Comparison.Value.Free;
  end;
end;

procedure TQueryBuilderComparisonTest.WhenCompareTheFieldWithAStringValueMustLoadTheComparisonAsExpected;
begin
  var Comparison: TQueryBuilderComparisonRecord;
  var Value := 'abc';

  for var Operation := Low(TQueryBuilderComparisonOperator) to High(TQueryBuilderComparisonOperator) do
  begin
    var Field := Field('MyField');

    case Operation of
      qbcoEqual: Comparison := Field = Value;
      qbcoGreaterThan: Comparison := Field > Value;
      qbcoGreaterThanOrEqual: Comparison := Field >= Value;
      qbcoLessThan: Comparison := Field < Value;
      qbcoLessThanOrEqual: Comparison := Field <= Value;
      qbcoNone, qbcoNull, qbcoNotNull, qbcoBetween:
      begin
        Field.Value.Free;

        Continue;
      end;
      qbcoNotEqual: Comparison := Field <> Value;
      else raise Exception.Create('Not implemented');
    end;

    var Left := Comparison.Value.Comparison;

    Assert.AreEqual('MyField', Left.Left.FieldNames[0]);
    Assert.AreEqual(Operation, Left.Operation);
    Assert.AreEqual(Value, Left.Right.Value.AsString);

    Comparison.Value.Free;
  end;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithFilledComparisons;
begin
  var Comparison := (Field('F1') = 'abc') and (Field('F2') = 'abc');

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Comparison.Value.Free;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithOperationAndFilled;
begin
  var Comparison := (Field('F1') = 'abc') and (Field('F2') = 'abc');

  Assert.AreEqual(qloAnd, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithFilledComparisons;
begin
  var Comparison := (Field('F1') = 'abc') or (Field('F2') = 'abc');

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Comparison.Value.Free;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithOperationOrFilled;
begin
  var Comparison := (Field('F1') = 'abc') or (Field('F2') = 'abc');

  Assert.AreEqual(qloOr, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

{ TQueryBuilderLogicalOperationTest }

procedure TQueryBuilderLogicalOperationTest.WhenAndOperatorMustLoadTheOperationWithTheAndValue;
begin
  var Comparison := (Field('MyField') = 'abc') and (Field('MyField2') = 'abc');

  Assert.AreEqual(qloAnd, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInAndOperator;
begin
  var Comparison := ((Field('F1') = 1) and (Field('F2') = 2)) and ((Field('F3') = 3) and (Field('F4') = 4));

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Left.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Value.Logical.Right.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F4', Comparison.Value.Logical.Right.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInOrOperator;
begin
  var Comparison := ((Field('F1') = 1) or (Field('F2') = 2)) or ((Field('F3') = 3) or (Field('F4') = 4));

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Left.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Value.Logical.Right.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F4', Comparison.Value.Logical.Right.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationAnd;
begin
  var Comparison := (Field('F1') = 1) and (Field('F2') = 2);

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationOr;
begin
  var Comparison := (Field('F1') = 1) or (Field('F2') = 2);

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheAndOperation;
begin
  var Comparison := (Field('F1') = 1) and ((Field('F2') = 2) and (Field('F3') = 3));

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Right.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Value.Logical.Right.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheOrOperation;
begin
  var Comparison := (Field('F1') = 1) or ((Field('F2') = 2) or (Field('F3') = 3));

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Right.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Value.Logical.Right.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheAndOperation;
begin
  var Comparison := ((Field('F1') = 1) and (Field('F2') = 2)) and (Field('F3') = 3);

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Left.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheOrOperation;
begin
  var Comparison := ((Field('F1') = 1) or (Field('F2') = 2)) or (Field('F3') = 3);

  Assert.AreEqual('F1', Comparison.Value.Logical.Left.Logical.Left.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Value.Logical.Left.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenOrOperatorMustLoadTheOperationWithTheOrValue;
begin
  var Comparison := (Field('MyField') = 'abc') or (Field('MyField2') = 'abc');

  Assert.AreEqual(qloOr, Comparison.Value.Logical.Operation);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenTheAndOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
begin
  var Comparison := (Field('MyField') = 'abc') and (Field('MyField2') = 'abc');

  Assert.AreEqual('MyField', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);
  Assert.AreEqual('MyField2', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Comparison.Value.Free;
end;

procedure TQueryBuilderLogicalOperationTest.WhenTheOrOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
begin
  var Comparison := (Field('MyField') = 'abc') or (Field('MyField2') = 'abc');

  Assert.AreEqual('MyField', Comparison.Value.Logical.Left.Comparison.Left.FieldNames[0]);
  Assert.AreEqual('MyField2', Comparison.Value.Logical.Right.Comparison.Left.FieldNames[0]);

  Comparison.Value.Free;
end;

{ TQueryBuilderWhereTest }

procedure TQueryBuilderWhereTest.AComposeLogicalOperationMustBeGeneratedAsExpected;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>.Where((Field('Field1') = 1) and (Field('Field2') = 2) or (Field('Field3') = 3));

  Assert.AreEqual(' where ((T1.Field1=1 and T1.Field2=2) or T1.Field3=3)', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.ASimpleLogicalAndOperationMustBeGeneratedAsExpected;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>.Where((Field('Field1') = 1111) and (Field('Field2') = 222));

  Assert.AreEqual(' where (T1.Field1=1111 and T1.Field2=222)', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.ASimpleLogicalOrOperationMustBeGeneratedAsExpected;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>.Where((Field('Field1') = 1111) or (Field('Field2') = 222));

  Assert.AreEqual(' where (T1.Field1=1111 or T1.Field2=222)', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.IfTheWhereDontFoundTheFieldMustRaiseAnError;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>;

  Assert.WillRaise(
    procedure
    begin
      Where.Where(Field('DontExists') = 1234);
    end, EFieldNotFoundInTable);

  From.Free;
end;

procedure TQueryBuilderWhereTest.Setup;
begin
  TMapper.Default.LoadAll;
end;

procedure TQueryBuilderWhereTest.TheComparisonOfTheValuesMustOccurAsExpected(TypeToConvert, ValueToCompare: String);
begin
  var FormatSettings := TFormatSettings.Invariant;
  FormatSettings.LongTimeFormat := 'hh":"mm":"ss';
  FormatSettings.ShortDateFormat := 'yyyy-mm-dd';
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Value: TValue;
  var Prefix := EmptyStr;

  if TypeToConvert = 'AnsiChar' then
    Value := TValue.From(AnsiChar('C'))
  else if TypeToConvert = 'AnsiString' then
    Value := TValue.From(AnsiString('AnsiString'))
  else if TypeToConvert = 'Char' then
    Value := TValue.From(Char('C'))
  else if TypeToConvert = 'Class' then
  begin
    var Obj := TMyEntityWithAllTypeOfFields.Create;
    Obj.Integer := 1234;
    Prefix := 'Id';
    Value := Obj;
  end
  else if TypeToConvert = 'EmptyClass' then
  begin
    Prefix := 'Id';
    Value := TValue.From<TObject>(nil);
  end
  else if TypeToConvert = 'Enumerator' then
    Value := TValue.From(Enum2)
  else if TypeToConvert = 'Float' then
    Value := 1234.456
  else if TypeToConvert = 'Date' then
    Value := TValue.From(EncodeDate(2020, 1, 31))
  else if TypeToConvert = 'DateTime' then
    Value := TValue.From(EncodeDateTime(2020, 1, 31, 12, 34, 56, 0))
  else if TypeToConvert = 'GUID' then
    Value := TValue.From(StringToGUID('{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}'))
  else if TypeToConvert = 'Integer' then
    Value := 1234
  else if TypeToConvert = 'Int64' then
    Value := Int64(1234)
  else if TypeToConvert = 'String' then
    Value := 'String'
  else if TypeToConvert = 'Time' then
    Value := TValue.From(TTime(EncodeTime(12, 34, 56, 0)))
  else
    raise Exception.Create('Test not mapped!');

  var Where := From.From<TMyEntityWithAllTypeOfFields>.Where(Field(TypeToConvert) = Value);

  Assert.AreEqual(Format(' where T1.%s%s=%s', [Prefix, TypeToConvert, ValueToCompare]), Where.GetSQL);

  if Value.IsObject then
    Value.AsObject.Free;

  From.Free;
end;

procedure TQueryBuilderWhereTest.TheComparisonOperatorsMustBeGeneratedAsExpected(Operation: TQueryBuilderComparisonOperator);
const
  COMPARISON_OPERATOR: array[TQueryBuilderComparisonOperator] of String = ('', '=', '<>', '>', '>=', '<', '<=', '', '', '');

begin
  var Comparison: TQueryBuilderComparisonRecord;
  var Field := Field('MyField');
  var ValueString := String('1');

  case Operation of
    qbcoBetween:
    begin
      Comparison := Field.Between('abc', 'efd');
      ValueString := ' between ''abc'' and ''efd''';
    end;
    qbcoEqual: Comparison := Field = 1;
    qbcoGreaterThan: Comparison := Field > 1;
    qbcoGreaterThanOrEqual: Comparison := Field >= 1;
    qbcoLessThan: Comparison := Field < 1;
    qbcoLessThanOrEqual: Comparison := Field <= 1;
    qbcoNone:
    begin
      Field.Value.Free;

      Assert.IsTrue(True);
    end;
    qbcoNotEqual: Comparison := Field <> 1;
    qbcoNotNull:
    begin
      Comparison := Field <> NULL;
      ValueString := ' is not null';
    end;
    qbcoNull:
    begin
      Comparison := Field = NULL;
      ValueString := ' is null';
    end;
    else raise Exception.Create('Test not implemented');
  end;

  if Operation <> qbcoNone then
  begin
    var From := TQueryBuilderFrom.Create(nil, 1);

    Assert.AreEqual(Format(' where T1.MyField%s%s', [COMPARISON_OPERATOR[Operation], ValueString]), From.From<TWhereClassTest>.Where(Comparison).GetSQL);

    From.Free;
  end;
end;

procedure TQueryBuilderWhereTest.TheLasNameInTheComposeNameMustBeTheFieldToBeFoundInAClass;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>.Where(Field('Where') = 1);

  Assert.AreEqual(' where T1.IdWhere=1', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.WhenBothOperationsAreLogicalHaveToGenerateSQLAsExpected;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>.Where((Field('Field1') = 1) and (Field('Field2') = 2) or (Field('Field3') = 3) and (Field('Field4') = 4));

  Assert.AreEqual(' where ((T1.Field1=1 and T1.Field2=2) or (T1.Field3=3 and T1.Field4=4))', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.WhenCompareAFieldWithAnValueMustBuildTheFilterAsExpected;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>.Where(Field('Value') = 1234);

  Assert.AreEqual(' where T1.Value=1234', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.WhenComparingFieldMustBuildTheFilterAsExpected(Operation: TQueryBuilderComparisonOperator);
const
  COMPARISON_OPERATOR: array[TQueryBuilderComparisonOperator] of String = ('', '=', '<>', '>', '>=', '<', '<=', '', '', '');

begin
  var Comparison: TQueryBuilderComparisonRecord;
  var FieldLeft := Field('MyField');
  var FieldValue := Field('Value');

  case Operation of
    qbcoEqual: Comparison := FieldLeft = FieldValue;
    qbcoGreaterThan: Comparison := FieldLeft > FieldValue;
    qbcoGreaterThanOrEqual: Comparison := FieldLeft >= FieldValue;
    qbcoLessThan: Comparison := FieldLeft < FieldValue;
    qbcoLessThanOrEqual: Comparison := FieldLeft <= FieldValue;
    qbcoNotEqual: Comparison := FieldLeft <> FieldValue;
    qbcoNone, qbcoNull, qbcoNotNull, qbcoBetween:
    begin
      FieldLeft.Value.Free;
      FieldValue.Value.Free;

      Assert.IsTrue(True);

      Exit;
    end;
    else raise Exception.Create('Test not implemented');
  end;

  var From := TQueryBuilderFrom.Create(nil, 1);

  Assert.AreEqual(Format(' where T1.MyField%sT1.Value', [COMPARISON_OPERATOR[Operation]]), From.From<TWhereClassTest>.Where(Comparison).GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.WhenExistsAJoinLoadedMustPutTheAliasOfTheTableBeforeTheFieldName;
begin
  var From := TQueryBuilderFrom.Create(nil, 2);
  var Where := From.From<TWhereClassTest>.Where(Field('Field1') = 1);

  Assert.AreEqual(' where T1.Field1=1', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.WhenLeftOperationIsASimpleComparisonAndRightIsALogicalOperationItHasToGenerateSQLAsExpected;
begin
  var From := TQueryBuilderFrom.Create(nil, 1);
  var Where := From.From<TWhereClassTest>.Where((Field('Field1') = 1) and ((Field('Field2') = 2) or (Field('Field3') = 3)));

  Assert.AreEqual(' where (T1.Field1=1 and (T1.Field2=2 or T1.Field3=3))', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.WhenUsingAComposeNameMustPutTheAliasOfTheTableBeforeTheFieldName;
begin
  var From := TQueryBuilderFrom.Create(nil, 2);
  var Where := From.From<TWhereClassTest>.Where(Field('Where.Class1.Class3.Id') = 1);

  Assert.AreEqual(' where T4.Id=1', Where.GetSQL);

  From.Free;
end;

procedure TQueryBuilderWhereTest.WhenUsingComposeFieldNameInAOperationWithoutFromMustRaiseAnError;
begin
  var Where := TQueryBuilderWhere<TWhereClassTest>.Create(nil);

  Assert.WillRaise(
    procedure
    begin
      Where.Where(Field('Where.Class1.Class3.Id') = 1);
    end, ECantUseComposeFieldName);

  Where.Free;
end;

end.

