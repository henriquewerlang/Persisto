unit Persisto.Mapper.Test;

interface

uses System.Rtti, Test.Insight.Framework, Data.Db, Persisto, Persisto.Mapping;

type
  [TestFixture]
  TMapperTest = class
  private
    FContext: TRttiContext;
    FMapper: TMapper;
  public
    [SetupFixture]
    procedure SetupFixture;
    [Setup]
    procedure Setup;
    [TearDown]
    procedure TearDown;
    [Test]
    procedure WhenCallLoadAllMustLoadAllClassesWithTheEntityAttribute;
    [Test]
    procedure WhenTryToFindATableMustReturnTheTableOfTheClass;
    [Test]
    procedure WhenLoadATableMustLoadAllFieldsToo;
    [Test]
    procedure WhenTheFieldsAreLoadedMustFillTheNameWithTheNameOfPropertyOfTheClass;
    [Test]
    procedure WhenLoadAClassMustKeepTheOrderingOfTablesToTheFindTableContinueToWorking;
    [Test]
    procedure WhenLoadAFieldMustFillThePropertyWithThePropertyInfo;
    [Test]
    procedure WhenAClassDoesNotHaveThePrimaryKeyAttributeAndHasAnIdFieldThisWillBeThePrimaryKey;
    [Test]
    procedure WhenTheClassHaveThePrimaryKeyAttributeThePrimaryKeyWillBeTheFieldFilled;
    [Test]
    procedure TheFieldInPrimaryKeyMustBeMarkedWithInPrimaryKey;
    [Test]
    procedure TheDatabaseNameOfATableMustBeTheNameOfClassRemovingTheFirstCharOfTheClassName;
    [Test]
    procedure WhenTheClassHaveTheTableNameAttributeTheDatabaseNameMustBeLikeTheNameInAttribute;
    [Test]
    procedure OnlyPublishedFieldMutsBeLoadedInTheTable;
    [Test]
    procedure WhenTheFieldHaveTheFieldNameAttributeMustLoadThisNameInTheDatabaseName;
    [Test]
    procedure EveryPropertyThatIsAnObjectMustCreateAForeignKeyInTheListOfTheTable;
    [Test]
    procedure WhenTheForeignKeyIsCreatesMustLoadTheParentTable;
    [Test]
    procedure TheParentTableMustBeTheTableLinkedToTheField;
    [Test]
    procedure WhenTheFieldIsAClassMustFillTheDatabaseNameWithIdPlusPropertyName;
    [Test]
    procedure TheFieldOfAForeignKeyMustBeFilledWithTheFieldOfTheClassThatIsAForeignKey;
    [Test]
    procedure TheLoadingOfForeingKeyMustBeAfterAllTablesAreLoadedToTheFindTableWorksPropertily;
    [Test]
    procedure WhenMapAForeignKeyIsToAClassWithoutAPrimaryKeyMustRaiseAnError;
    [Test]
    procedure WhenCallLoadAllMoreThemOneTimeCantRaiseAnError;
    [Test]
    procedure TheClassWithTheSingleTableInheritanceAttributeCantBeMappedInTheTableList;
    [Test]
    procedure WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeMustLoadAllFieldsInTheTable;
    [Test]
    procedure WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeCantGenerateAnyForeignKey;
    [Test]
    procedure WhenTheClassIsInheritedFromANormalClassCantLoadFieldsFormTheBaseClass;
    [Test]
    procedure WhenTheClassIsInheritedFromANormalClassMustCreateAForeignKeyForTheBaseClass;
    [Test]
    procedure WhenTheClassIsInheritedFromTObjectCantCreateAForeignKeyForThatClass;
    [Test]
    procedure WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeThePrimaryKeyMustBeLoadedFromTheTopClass;
    [Test]
    procedure WhenTheClassIsInheritedMustLoadThePrimaryKeyFromBaseClass;
    [Test]
    procedure WhenTheForeignKeyIsAClassAliasMustLoadTheForeignClassAndLinkToForeignKey;
    [Test]
    procedure WhenLoadMoreThenOneTimeTheSameClassCantRaiseAnError;
    [Test]
    procedure WhenAPropertyIsAnArrayMustLoadAManyValueLink;
    [Test]
    procedure TheTableOfManyValueAssociationMustBeTheChildTableOfThisLink;
    [Test]
    procedure TheFieldLinkingTheParentAndChildOfManyValueAssociationMustBeLoaded;
    [Test]
    procedure WhenTheChildClassIsDeclaredBeforeTheParentClassTheLinkBetweenOfTablesMustBeCreated;
    [Test]
    procedure WhenAFieldIsWithTheAutoGeneratedAttributeMustLoadAsTrueThePropertyInField;
    [Test]
    procedure WhenAFieldIsAForeignKeyThePropertyIsForeignKeyMustReturnTrue;
    [Test]
    procedure WhenAFieldIsAManyValueAssociationThePropertyIsManyValueAssociationReturnTrue;
    [Test]
    procedure TheFunctionGetValueFromFieldMustReturnTheValueOfThePropertyOfTheField;
    [Test]
    procedure WhenTheFieldIsMappedMustLoadTheReferenceToTheTableOfTheField;
    [Test]
    procedure WhenAClassWithManyValueAssociationHasAChildClassWithMoreThenOneForeignKeyToParentClassMustLoadTheForeignKeyWithTheSameNameOfTheParentTable;
    [Test]
    procedure WhenTheLinkBetweenTheManyValueAssociationAndTheChildTableForeignKeyDontExistsMustRaiseAnError;
    [Test]
    procedure TheNameOfManyValueAssociationLinkCanBeDefinedByTheAttributeToTheLinkHappen;
    [Test]
    procedure WhenATableIsLoadedMustFillTheMapperPropertyOfTheTable;
    [Test]
    procedure WhenThePropertyIsNullableMustMarkTheFieldAsNotRequired;
    [Test]
    procedure WhenGetValueOfAndFieldNullableMustReturnEmptyIfHasNoValue;
    [Test]
    procedure WhenTheNullablePropertyIsLoadedMustReturnTheFilled;
    [Test]
    procedure WhenTheNullablePropertyIsFilledWithAValueMustLoadTheValue;
    [Test]
    procedure WhenThePropertyIsLazyMustFillWithTrueTheIsLazyPropertyInTheField;
    [Test]
    procedure WhenThePropertyIsLazyMustReturnTheFieldTypeWithTheInternalLazyType;
    [Test]
    procedure WhenThePropertyIsLazyMustCreateTheForeignKeyToThisProperty;
    [Test]
    procedure TheFieldThatGenerateAForignKeyMustLoadThisInfoInTheField;
    [Test]
    procedure WhenTheFieldIsAForeignKeyMustAppendTheIdInTheDatabaseNameOfTheField;
    [Test]
    procedure TheFieldsMustBeOrderedByPriorityFirstPrimaryKeyThenRegularFieldsThenForeignKeysThenManyValueAssociations;
    [Test]
    procedure WhenTheLazyPropertyIsLoadedMustReturnTheInternalValue;
    [Test]
    procedure WhenLoadTheTableMustLoadTheNameOfTheTableWithTheNameOfTheClassWithoutTheTChar;
    [Test]
    procedure WhenLoadTheFieldOfATableMustLoadTheNameOfTheFieldWithThePropertyName;
    [Test]
    procedure WhenLoadAFieldMustLoadTheFieldTypeWithTheTypeOfTheProperty;
    [Test]
    procedure WhenLoadANullableFieldMustLoadTheFieldTypeWithTheInternalNullableType;
    [Test]
    procedure WhenTheClassHasAForeignKeyAndTheKeyTableIsntLoadedMustLoadTheTableFirstAndNotRaiseAnError;
    [Test]
    procedure TheFindTableWithTypeInfoMustReturnTheTableHasExpected;
    [Test]
    procedure WhenTheClassHasASimpleInheritenceMustLoadTheBaseTableProperty;
    [Test]
    procedure WhenTheClassInheritsFromObjectCantRaiseAnyError;
    [Test]
    procedure IfTheBaseClassHasTheSingleTableAttributeCantLoadBaseTableProperty;
    [Test]
    procedure TheFindFieldFunctionMustReturnTrueIfTheFieldExistsInTheTable;
    [Test]
    procedure TheFindFieldFunctionMustReturnTheFieldDefinitionWhenFindTheField;
    [Test]
    procedure TheForeignKeyCreatedForTheInheritanceMustBeMarkedHasInheritanceLink;
    [Test]
    procedure WhenAForeignKeyFieldHasTheFieldNameAttributeThisMustBeTheDatabaseNameField;
    [Test]
    procedure ThenMakeAForeignKeyToASingleTableInheritanceMustRaiseAnError;
    [Test]
    procedure MappingAEntityWithForeignKeyToASingleInheritedClassCantRaiseError;
    [Test]
    procedure WhenLoadATableWithSingleInheritenceMustLoadTheFieldsOfAllLevels;
    [Test]
    procedure WhenTheTableIsInheritedMustLoadAllManyValueAssociationOfTheClass;
    [Test]
    procedure WhenMappingALazyArrayClassCantRaiseAnyError;
    [Test]
    procedure WhenMappingALazyArrayClassMustLoadTheFieldWithTheExpectedPropertyValueFilled;
    [Test]
    procedure TheForeignKeyDatabaseNameMustBeTheConcatenationOfTheTablesAndFieldInfo;
    [Test]
    procedure IfTheForeignKeyHasTheNameAttributeTheDatabaseNameMustBeTheAttributeValue;
    [Test]
    procedure WhenTheClassHasTheIndexAnnotationMustLoadTheIndexInfoOfTheTable;
    [Test]
    procedure WhenLoadTheIndexMustLoadTheNameOfTheIndexHasExpected;
    [Test]
    procedure WhenUseTheUniqueIndexAttributeMustMarkTheIndexAsUnique;
    [Test]
    procedure MustLoadTheFieldsInTheIndexHasExpected;
    [Test]
    procedure IfTheFieldInIndexNotExistsInTheTableMustRaiseAnError;
    [Test]
    procedure WhenTheFieldHasFieldInfoAttributeWithSpecialTypeFilledMustLoadThisInfoInTheField;
    [Test]
    procedure WhenTheFieldHasFieldInfoAttributeWithSizeFilledMustLoadThisInfoInTheField;
    [Test]
    procedure WhenTheFieldHasFieldInfoAttributeWithPrecisionAndScaleFilledMustLoadThisInfoInTheField;
    [Test]
    procedure TheFieldTablePropertyMustReturnTheFieldIfFoundIt;
    [Test]
    procedure WhenTheFieldIsOfDateTypeMustLoadTheSpecialTypeWithDate;
    [Test]
    procedure WhenTheFieldIsOfDateTimeTypeMustLoadTheSpecialTypeWithDateTime;
    [Test]
    procedure WhenTheFieldIsOfTimeTypeMustLoadTheSpecialTypeWithTime;
    [Test]
    procedure IfTheFieldIsLazyAndHasAnValueLoadedMustReturnTrueInTheHasValueFunction;
    [Test]
    procedure IfTheFieldIsAClassMustReturnTrueInTheHasValueFunctionIfTheClassValueIsLoaded;
    [Test]
    procedure IfTheFieldIsAClassMustReturnFalseInTheHasValueFunctionIfTheClassValueIsNotLoaded;
    [Test]
    procedure IfTheFieldIsNullableMustReturnFalseInTheHasValueFunctionIfTheValueNotLoaded;
    [Test]
    procedure ThePrimaryKeyReferenceInAnInheritedClassMustHaveSameTypeOfTheKeyOfTheBaseType;
    [Test]
    procedure WhenTheFieldIsBooleanTypeMustLoadTheSpecialTypeWithBoolean;
    [Test]
    procedure WhenTheLazyFieldIsntChangedCantRaiseAnyErrorWhenTryToGetTheLazyValue;
    [Test]
    procedure WhenTheFieldIsLazyLoadingAndTheValueIsntLoadedMustReturnFalseInTheFunction;
    [Test]
    procedure WhenTheFieldIsLazyLoadingAndTheValueIsntLoadedMustReturnEmptyValueInParam;
    [Test]
    procedure IfTheFieldIsLazyLoadingAndHasntValueMustReturnFalseInHasValueFunction;
    [Test]
    procedure WhenTheFieldIsManyValueAssociationMustLoadTheManyValuePropertyOfTheField;
    [Test]
    procedure WhenTheLazyFieldIsntLoadedAndHaveAKeyFilledMustReturnTheKeyValueInGetValueFunction;
    [Test]
    procedure WhenTheFieldIsRequiredMustLoadThisInfoInTheField;
//    [TestCase('AnsiChar', 'AnsiChar')]
//    [TestCase('Char', 'Char')]
//    [TestCase('Enumerator', 'Enumerator')]
//    [TestCase('Float', 'Float')]
//    [TestCase('Date', 'Date')]
//    [TestCase('DateTime', 'DateTime')]
//    [TestCase('Integer', 'Integer')]
//    [TestCase('Int64', 'Int64')]
//    [TestCase('Time', 'Time')]
    procedure WhenThePropertyIsANativeTypeMustMarkTheFieldAsRequired(const FieldName: String);
    [Test]
    procedure WhenTheFieldIsAClassMustMarkAsNotRequired;
    [Test]
    procedure IfTheFieldIsANullableTypeMustBeMarkedHasNotRequired;
    [Test]
    procedure WhenANotRequiredPropertyHasTheRequiredAttributeMustMarkTheFieldHasRequired;
    [Test]
    procedure WhenAFieldIsAutoGeneratedMustLoadTheDefaultConstraintInfoOfTheField;
    [Test]
    procedure WhenTheFieldIsntAutoGeneratedTheDefaultConstraintMustBeNil;
    [Test]
    procedure TheDefaultConstraintMustHaveTheAutoGeneratedTypeLoadedHasExpected;
    [Test]
    procedure TheDatabaseNameOfDefaultConstraintMustBeGeneratedAsExpected;
    [Test]
    procedure WhenTheAttributeIsASequenceMustLoadTheNameOfTheSequenceInTheDefaultConstraint;
    [Test]
    procedure WhenTheFieldHasTheFixedValueAttributeMustLoadTheValueInTheDefaultConstraint;
    [Test]
    procedure WhenTheFieldHasAForeignKeyToASpecialFieldTheSpecialTypeOfTheFieldMustBeEqualToThePrimaryKeyOfForeignKeyClass;
    [Test]
    procedure IfTheForeignKeyTableHasASpecialAttributeInThePrimaryKeyTheSpecialTypeOfTheFieldMustBeTheSame;
    [Test]
    procedure WhenTheForeignKeyTableHasAFloatKeyMustLoadThePrecisionAndSizeFromThePrimaryKey;
    [Test]
    procedure TheFieldTypeOfAForeignKeyMustBeEqualToThePrimaryKeyOfForeignKeyTable;
    [Test]
    procedure WhenTheTableHasAPrimaryKeyMustCreateAnIndexForThePrimaryKey;
    [Test]
    procedure TheNameOfPrimaryKeyIndexMustBeAsExpected;
    [Test]
    procedure ThePrimaryKeyIndexMustLoadThePrimaryKeyFieldInTheIndexFieldList;
    [Test]
    procedure ThePrimaryKeyIndexMustBeMarkedAsUniqueAndInPrimaryKey;
    [Test]
    procedure WhenLoadTheSchemaWithAClassInParamsTheMapperMustLoadOnlyTheClassesInTheUnitOfThatClass;
    [Test]
    procedure WhenLoadTheSchemaMustLoadAllClassesFromTheUnitsPassedInTheParams;
    [Test]
    procedure WhenAddADefaultRecordMustAddThisValueToTheTableOfTheObject;
    [Test]
    procedure WhenTheFieldAsTheSequenceAttributeMustLoadTheSequenceInTheList;
    [Test]
    procedure TheSequenceNameMustBeLoadedWithTheNameInsideTheAttribute;
    [Test]
    procedure WhenAlreadyExistsTheSequenceMappedMustRaiseAnError;
    [Test]
    procedure WhenTheClassHasntPublishedFieldsMustRaiseAnError;
    [Test]
    procedure AutoGeneratingFieldsMustBeLoadedInTheReturningFieldsProperty;
    [Test]
    procedure TheReturningFieldPropertyMustHaveTheFieldInfoLoaded;
    [Test]
    procedure WhenATableHasPrimaryKeyThePropertyMustReturnTrue;
    [Test]
    procedure WhenLoadATableWithMoreThenOneLevelWithSingleInheritenceMustLoadTheFieldsAsExpected;
    [Test]
    procedure WhenLoadAnInheritedTableThePrimaryKeyFieldCantBeAutoGenerated;
    [Test]
    procedure WhenLoadATableMustLoadAllFieldsCountWithTheTotalFieldOfTheTable;
    [Test]
    procedure WhenLoadAnInheritedTableTheAllFieldCountPropertyMustCountTheFieldFromBaseClassesToo;
    [Test]
    procedure TheFieldIndexMustMustBeLoadBasedInTheFieldCountOfTheTable;
    [Test]
    procedure WhenLoadAnInheritedTableTheFieldIndexMustBaseAdjustedToTheCountOfFieldInTheBaseClass;
    [Test]
    procedure ThenManyValueAssociationMustLoadTheFieldInfo;
    [Test]
    procedure WhenGetTheLazyValueFromAFieldMustReturnTheInternalInstanceOfTheInterface;
    [Test]
    procedure WhenFillTheLazyValueFromAFieldMustLoadTheFieldValueOfTheLazyRecord;
    [Test]
    procedure WhenLoadALazyFieldMustLoadTheLazyTypeInfoAsExpected;
    [Test]
    procedure WhenFillTheObjectOfALazyFieldMustReturnTheValueWhenGetTheValueAgain;
    [Test]
    procedure WhenGetValueFromANullablePropertyAndTheStoredValueIsFalseMustReturnAnEmptyValue;
    [Test]
    procedure TheFieldDatabaseTypeMustBeEqualTheValueExpected;
    [Test]
    procedure WhenAPropertyIsAStringTypeMustBeNotRequired;
    [Test]
    procedure ThePrimaryKeyFieldMustBeMarkedAsRequiredAlways;
    [Test]
    procedure WhenLoadATableWithInheritenceWithoutAnyFieldsCantRaiseLoadError;
    [Test]
    procedure WhenTheLazyValueHasOnlyTheKeyLoadedMustReturnTrueInTheFieldValue;
    [Test]
    procedure IfTheLazyFieldIsNotLoadedMustReturnValueInTheHasValueFunction;
    [Test]
    procedure WhenTheClassHasAnArrayWithTypeNotEqualToObjectCanLoadTheManyValueFromThisProperty;
    [Test]
    procedure WhenSetTheFieldValueAndTheFieldIsLazyMustReturnTheValueFilled;
    [Test]
    procedure WhenTheFieldHasTheBinaryAttributeMustLoadTheSpecialTypeAsExpected;
    [Test]
    procedure WhenTheFieldIsBinaryCantBeRequiredByDefault;
    [Test]
    procedure WhenGetTableByQualifiedNameMustReturnTheTableInformationHasExpected;
    [Test]
    procedure WhenGetTableByNameAndTheClassNameNotExistsCantRaiseAnyError;
    [Test]
    procedure WhenTheFieldIsntFoundMustRaiseAnError;
    [Test]
    procedure WhenTryToFindAFieldMustIgnoreTheFieldNameCase;
  end;

implementation

uses System.Variants, System.SysUtils, System.DateUtils, System.TypInfo, Persisto.Test.Entity;

{ TMapperTest }

procedure TMapperTest.AutoGeneratingFieldsMustBeLoadedInTheReturningFieldsProperty;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual(4, Length(Table.ReturningFields));
end;

procedure TMapperTest.EveryPropertyThatIsAnObjectMustCreateAForeignKeyInTheListOfTheTable;
begin
  var Table := FMapper.GetTable(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual(2, Length(Table.ForeignKeys));
end;

procedure TMapperTest.IfTheBaseClassHasTheSingleTableAttributeCantLoadBaseTableProperty;
begin
  var Table := FMapper.GetTable(TMyEntityInheritedFromSingle);

  Assert.IsNil(Table.BaseTable);
end;

procedure TMapperTest.IfTheFieldInIndexNotExistsInTheTableMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      FMapper.GetTable(TMyClassWithIndexWithError);
    end, Exception);
end;

procedure TMapperTest.IfTheFieldIsAClassMustReturnFalseInTheHasValueFunctionIfTheClassValueIsNotLoaded;
begin
  var MyClass := TClassWithForeignKey.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Assert.IsFalse(Table.Field['AnotherClass'].HasValue(MyClass, Value));

  MyClass.Free;
end;

procedure TMapperTest.IfTheFieldIsAClassMustReturnTrueInTheHasValueFunctionIfTheClassValueIsLoaded;
begin
  var MyClass := TClassWithForeignKey.Create;
  MyClass.AnotherClass := TClassWithPrimaryKey.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Assert.IsTrue(Table.Field['AnotherClass'].HasValue(MyClass, Value));

  MyClass.AnotherClass.Free;

  MyClass.Free;
end;

procedure TMapperTest.IfTheFieldIsANullableTypeMustBeMarkedHasNotRequired;
begin
  var Table := FMapper.GetTable(TClassWithNullableProperty);

  Assert.IsFalse(Table.Field['Nullable'].Required);
end;

procedure TMapperTest.IfTheFieldIsLazyAndHasAnValueLoadedMustReturnTrueInTheHasValueFunction;
begin
  var MyClass := TLazyClass.Create;
  MyClass.Lazy.Value := TMyEntity.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Assert.IsTrue(Table.Field['Lazy'].HasValue(MyClass, Value));

  MyClass.Lazy.Value.Free;

  MyClass.Free;
end;

procedure TMapperTest.IfTheFieldIsLazyLoadingAndHasntValueMustReturnFalseInHasValueFunction;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  MyClass.Lazy.Value;

  Assert.IsFalse(Table.Field['Lazy'].HasValue(MyClass, Value));

  MyClass.Free;
end;

procedure TMapperTest.IfTheFieldIsNullableMustReturnFalseInTheHasValueFunctionIfTheValueNotLoaded;
begin
  var MyClass := TClassWithNullableProperty.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Assert.IsFalse(Table.Field['Nullable'].HasValue(MyClass, Value));

  MyClass.Free;
end;

procedure TMapperTest.IfTheForeignKeyHasTheNameAttributeTheDatabaseNameMustBeTheAttributeValue;
begin
  var Table := FMapper.GetTable(TMyEntityForeignKeyWithName);

  Assert.AreEqual('MyForeignKey', Table.ForeignKeys[0].DatabaseName);
end;

procedure TMapperTest.IfTheForeignKeyTableHasASpecialAttributeInThePrimaryKeyTheSpecialTypeOfTheFieldMustBeTheSame;
begin
  var Table := FMapper.GetTable(TForeignKeyClassToSpecialCase);

  Assert.AreEqual(stUniqueIdentifier, Table.Field['SpecialTypeForeignKey'].SpecialType)
end;

procedure TMapperTest.IfTheLazyFieldIsNotLoadedMustReturnValueInTheHasValueFunction;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Table.Field['Lazy'].LazyValue[MyClass] := TLazyLoader.Create(nil, nil, TValue.Empty, nil);

  Assert.IsFalse(Table.Field['Lazy'].HasValue(MyClass, Value));

  MyClass.Free;
end;

procedure TMapperTest.MappingAEntityWithForeignKeyToASingleInheritedClassCantRaiseError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable(TMyEntityForeignKeyToConcrete);
    end);
end;

procedure TMapperTest.MustLoadTheFieldsInTheIndexHasExpected;
begin
  var MyField, MyField2: TField;
  var Table := FMapper.GetTable(TMyClassWithIndex);

  Table.FindField('MyField', MyField);
  Table.FindField('MyField2', MyField2);

  Assert.AreEqual(2, Length(Table.Indexes[2].Fields));
  Assert.AreEqual(MyField, Table.Indexes[2].Fields[0]);
  Assert.AreEqual(MyField2, Table.Indexes[2].Fields[1]);
end;

procedure TMapperTest.OnlyPublishedFieldMutsBeLoadedInTheTable;
begin
  var Table := FMapper.GetTable(TMyEntity);

  Assert.AreEqual(3, Length(Table.Fields));
end;

procedure TMapperTest.Setup;
begin
  FMapper := TMapper.Create;
end;

procedure TMapperTest.SetupFixture;
begin
  FContext.GetType(TClassWithPrimaryKey).QualifiedName;
end;

procedure TMapperTest.TearDown;
begin
  FMapper.Free;
end;

procedure TMapperTest.TheClassWithTheSingleTableInheritanceAttributeCantBeMappedInTheTableList;
begin
  Assert.IsNil(FMapper.GetTable(TMyEntityWithSingleTableInheritanceAttribute));
end;

procedure TMapperTest.TheDatabaseNameOfATableMustBeTheNameOfClassRemovingTheFirstCharOfTheClassName;
begin
  var Table := FMapper.GetTable(TMyEntity);

  Assert.AreEqual('MyEntity', Table.DatabaseName);
end;

procedure TMapperTest.TheDatabaseNameOfDefaultConstraintMustBeGeneratedAsExpected;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual('DF_AutoGeneratedClass_Id', Table.Field['Id'].DefaultConstraint.DatabaseName);
end;

procedure TMapperTest.TheDefaultConstraintMustHaveTheAutoGeneratedTypeLoadedHasExpected;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual(agtNewUniqueIdentifier, Table.Field['Id'].DefaultConstraint.AutoGeneratedType);
end;

procedure TMapperTest.TheFieldDatabaseTypeMustBeEqualTheValueExpected;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(ftWideString, Table.Field['AnsiChar'].DatabaseType);
  Assert.AreEqual(ftString, Table.Field['AnsiString'].DatabaseType);
  Assert.AreEqual(ftBoolean, Table.Field['Boolean'].DatabaseType);
  Assert.AreEqual(ftWideString, Table.Field['Char'].DatabaseType);
  Assert.AreEqual(ftDate, Table.Field['Date'].DatabaseType);
  Assert.AreEqual(ftDateTime, Table.Field['DateTime'].DatabaseType);
  Assert.AreEqual(ftInteger, Table.Field['Enumerator'].DatabaseType);
  Assert.AreEqual(ftFloat, Table.Field['Float'].DatabaseType);
  Assert.AreEqual(ftLargeint, Table.Field['Int64'].DatabaseType);
  Assert.AreEqual(ftInteger, Table.Field['Integer'].DatabaseType);
  Assert.AreEqual(ftWideString, Table.Field['String'].DatabaseType);
  Assert.AreEqual(ftMemo, Table.Field['Text'].DatabaseType);
  Assert.AreEqual(ftTime, Table.Field['Time'].DatabaseType);
  Assert.AreEqual(ftGuid, Table.Field['UniqueIdentifier'].DatabaseType);
end;

procedure TMapperTest.TheFieldIndexMustMustBeLoadBasedInTheFieldCountOfTheTable;
begin
  var Table := FMapper.GetTable(TClassLevel1);

  Assert.AreEqual(0, Table.Field['Id'].Index);
  Assert.AreEqual(1, Table.Field['Field1'].Index);
end;

procedure TMapperTest.TheFieldInPrimaryKeyMustBeMarkedWithInPrimaryKey;
begin
  var Table := FMapper.GetTable(TMyEntity);

  Assert.IsTrue(Table.PrimaryKey.InPrimaryKey);
end;

procedure TMapperTest.TheFieldLinkingTheParentAndChildOfManyValueAssociationMustBeLoaded;
begin
  var ChildTable := FMapper.GetTable(TMyEntityWithManyValueAssociationChild);
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(ChildTable.Field['ManyValueAssociation'], Table.ManyValueAssociations[0].ChildField);
end;

procedure TMapperTest.TheFieldOfAForeignKeyMustBeFilledWithTheFieldOfTheClassThatIsAForeignKey;
begin
  var Table := FMapper.GetTable(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual(Table.Fields[1], Table.ForeignKeys[0].Field);
end;

procedure TMapperTest.TheFieldsMustBeOrderedByPriorityFirstPrimaryKeyThenRegularFieldsThenForeignKeysThenManyValueAssociations;
begin
  var Table := FMapper.GetTable(TUnorderedClass);

  Assert.AreEqual('Id', Table.Fields[0].DatabaseName);
  Assert.AreEqual('AField', Table.Fields[1].DatabaseName);
  Assert.AreEqual('BField', Table.Fields[2].DatabaseName);
  Assert.AreEqual('LastField', Table.Fields[5].DatabaseName);
  Assert.AreEqual('IdALazy', Table.Fields[3].DatabaseName);
  Assert.AreEqual('IdBLazy', Table.Fields[4].DatabaseName);
  Assert.AreEqual('IdAForeignKey', Table.Fields[6].DatabaseName);
  Assert.AreEqual('IdBForeignKey', Table.Fields[7].DatabaseName);
  Assert.AreEqual('AManyValue', Table.Fields[8].DatabaseName);
  Assert.AreEqual('BManyValue', Table.Fields[9].DatabaseName);
end;

procedure TMapperTest.TheFieldTablePropertyMustReturnTheFieldIfFoundIt;
begin
  var Field: TField;
  var Table := FMapper.GetTable(TMyTestClass);

  Table.FindField('Field', Field);

  Assert.AreEqual(Field, Table.Field['Field']);
end;

procedure TMapperTest.TheFieldThatGenerateAForignKeyMustLoadThisInfoInTheField;
begin
  var Table := FMapper.GetTable(TClassWithForeignKey);

  Assert.IsNotNil(Table.Fields[1].ForeignKey);
end;

procedure TMapperTest.TheFieldTypeOfAForeignKeyMustBeEqualToThePrimaryKeyOfForeignKeyTable;
begin
  var Table := FMapper.GetTable(TForeignKeyClassToSpecialCase);

  Assert.AreEqual(FContext.GetType(TypeInfo(Double)), Table.Field['FloatForeignKey'].FieldType);
end;

procedure TMapperTest.TheFindFieldFunctionMustReturnTheFieldDefinitionWhenFindTheField;
begin
  var Field: TField;
  var Table := FMapper.GetTable(TUnorderedClass);

  Table.FindField('BForeignKey', Field);

  Assert.AreEqual(Table.Fields[7], Field);
end;

procedure TMapperTest.TheFindFieldFunctionMustReturnTrueIfTheFieldExistsInTheTable;
begin
  var Field: TField;
  var Table := FMapper.GetTable(TUnorderedClass);

  Assert.IsTrue(Table.FindField('BForeignKey', Field));
end;

procedure TMapperTest.TheFindTableWithTypeInfoMustReturnTheTableHasExpected;
begin
  FMapper.GetTable(TClassWithForeignKey);

  Assert.IsNotNil(FMapper.GetTable(TClassWithForeignKey.ClassInfo));
end;

procedure TMapperTest.TheForeignKeyCreatedForTheInheritanceMustBeMarkedHasInheritanceLink;
begin
  var Table := FMapper.GetTable(TMyEntityInheritedFromSimpleClass);

  Assert.IsTrue(Table.Field['Id'].IsInheritedLink);
end;

procedure TMapperTest.TheForeignKeyDatabaseNameMustBeTheConcatenationOfTheTablesAndFieldInfo;
begin
  var Table := FMapper.GetTable(TMyEntityForeignKeyAlias);

  Assert.AreEqual('FK_MyEntityForeignKeyAlias_IdForeignKey', Table.ForeignKeys[0].DatabaseName);
end;

procedure TMapperTest.TheFunctionGetValueFromFieldMustReturnTheValueOfThePropertyOfTheField;
begin
  var MyClass := TMyEntityWithAllTypeOfFields.Create;
  MyClass.&String := 'My Field';
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  var Field := Table.Field['String'];

  Assert.AreEqual('My Field', Field.Value[MyClass].AsString);

  MyClass.Free;
end;

procedure TMapperTest.TheLoadingOfForeingKeyMustBeAfterAllTablesAreLoadedToTheFindTableWorksPropertily;
begin
  var Table := FMapper.GetTable(TZZZZ);

  Assert.IsNotNil(Table.ForeignKeys[0].ParentTable);
end;

procedure TMapperTest.TheNameOfManyValueAssociationLinkCanBeDefinedByTheAttributeToTheLinkHappen;
begin
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  Assert.AreEqual('ManyValueAssociation', Table.ManyValueAssociations[0].ChildField.PropertyInfo.Name);
end;

procedure TMapperTest.TheNameOfPrimaryKeyIndexMustBeAsExpected;
begin
  var Table := FMapper.GetTable(TMyEntity2);

  Assert.AreEqual('PK_AnotherTableName', Table.Indexes[0].DatabaseName);
end;

procedure TMapperTest.ThenMakeAForeignKeyToASingleTableInheritanceMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      FMapper.GetTable(TMyEntityForeignKeyToAnotherSingle);
    end, EForeignKeyToSingleTableInheritanceTable);
end;

procedure TMapperTest.ThenManyValueAssociationMustLoadTheFieldInfo;
begin
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(Table.Field['ManyValueAssociationList'], Table.ManyValueAssociations[0].Field);
end;

procedure TMapperTest.TheParentTableMustBeTheTableLinkedToTheField;
begin
  var ParentTable := FMapper.GetTable(TMyEntityWithPrimaryKey);
  var Table := FMapper.GetTable(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual(ParentTable, Table.ForeignKeys[0].ParentTable);
end;

procedure TMapperTest.ThePrimaryKeyFieldMustBeMarkedAsRequiredAlways;
begin
  var Table := FMapper.GetTable(TClassWithPrimaryKeyNullableProperty);

  Assert.IsTrue(Table.Field['Id'].Required);
end;

procedure TMapperTest.ThePrimaryKeyIndexMustBeMarkedAsUniqueAndInPrimaryKey;
begin
  var Table := FMapper.GetTable(TClassWithPrimaryKey);

  Assert.IsTrue(Table.Indexes[0].IsPrimaryKey);

  Assert.IsTrue(Table.Indexes[0].IsUnique);
end;

procedure TMapperTest.ThePrimaryKeyIndexMustLoadThePrimaryKeyFieldInTheIndexFieldList;
begin
  var Table := FMapper.GetTable(TClassWithPrimaryKey);

  Assert.AreEqual(1, Length(Table.Indexes[0].Fields));

  Assert.AreEqual(Table.PrimaryKey, Table.Indexes[0].Fields[0]);
end;

procedure TMapperTest.ThePrimaryKeyReferenceInAnInheritedClassMustHaveSameTypeOfTheKeyOfTheBaseType;
begin
  var TableChild := FMapper.GetTable(TMyEntityInheritedFromSimpleClass);
  var TableParent := FMapper.GetTable(TMyEntityInheritedFromSingle);

  Assert.AreEqual(TableParent.PrimaryKey.FieldType, TableChild.PrimaryKey.FieldType);
end;

procedure TMapperTest.TheReturningFieldPropertyMustHaveTheFieldInfoLoaded;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual(Table.Field['Id'], Table.ReturningFields[0]);
  Assert.AreEqual(Table.Field['AnotherField'], Table.ReturningFields[1]);
end;

procedure TMapperTest.TheSequenceNameMustBeLoadedWithTheNameInsideTheAttribute;
begin
  var Mapper := TMapper.Create;

  Mapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual('MySequence', Mapper.Sequences[0].Name);

  Mapper.Free;
end;

procedure TMapperTest.TheTableOfManyValueAssociationMustBeTheChildTableOfThisLink;
begin
  var ChildTable := FMapper.GetTable(TMyEntityWithManyValueAssociationChild);
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(ChildTable, Table.ManyValueAssociations[0].ChildTable);
end;

procedure TMapperTest.WhenAClassDoesNotHaveThePrimaryKeyAttributeAndHasAnIdFieldThisWillBeThePrimaryKey;
begin
  var Table := FMapper.GetTable(TMyEntity2);

  Assert.AreEqual('Id', Table.PrimaryKey.DatabaseName);
end;

procedure TMapperTest.WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeCantGenerateAnyForeignKey;
begin
  Assert.AreEqual(0, Length(FMapper.GetTable(TMyEntityInheritedFromSingle).ForeignKeys));
end;

procedure TMapperTest.WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeMustLoadAllFieldsInTheTable;
begin
  Assert.AreEqual(3, Length(FMapper.GetTable(TMyEntityInheritedFromSingle).Fields));
end;

procedure TMapperTest.WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeThePrimaryKeyMustBeLoadedFromTheTopClass;
begin
  var Table := FMapper.GetTable(TMyEntityInheritedFromSingle);

  Assert.IsTrue(Assigned(Table.PrimaryKey));
end;

procedure TMapperTest.WhenAClassWithManyValueAssociationHasAChildClassWithMoreThenOneForeignKeyToParentClassMustLoadTheForeignKeyWithTheSameNameOfTheParentTable;
begin
  var Table := FMapper.GetTable(TManyValueAssociationParent);

  Assert.AreEqual('IdManyValueAssociationParent', Table.ManyValueAssociations[0].ChildField.DatabaseName);
end;

procedure TMapperTest.WhenAddADefaultRecordMustAddThisValueToTheTableOfTheObject;
begin
  var MyClass := TMyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  FMapper.AddDefaultRecord(MyClass);

  Assert.AreEqual(1, Table.DefaultRecords.Count);
end;

procedure TMapperTest.WhenAFieldIsAForeignKeyThePropertyIsForeignKeyMustReturnTrue;
begin
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociationChild);

  var Field := Table.Field['ManyValueAssociation'];

  Assert.IsTrue(Field.IsForeignKey);
end;

procedure TMapperTest.WhenAFieldIsAManyValueAssociationThePropertyIsManyValueAssociationReturnTrue;
begin
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  var Field := Table.Field['ManyValueAssociationList'];

  Assert.IsTrue(Field.IsManyValueAssociation);
end;

procedure TMapperTest.WhenAFieldIsAutoGeneratedMustLoadTheDefaultConstraintInfoOfTheField;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.IsNotNil(Table.Field['Id'].DefaultConstraint);
end;

procedure TMapperTest.WhenAFieldIsWithTheAutoGeneratedAttributeMustLoadAsTrueThePropertyInField;
begin
  var Table := FMapper.GetTable(TMyEntity);

  Assert.IsTrue(Table.Fields[0].AutoGenerated);
end;

procedure TMapperTest.WhenAForeignKeyFieldHasTheFieldNameAttributeThisMustBeTheDatabaseNameField;
begin
  var Table := FMapper.GetTable(TClassWithNamedForeignKey);

  Assert.AreEqual('MyFk', Table.Field['ForeignKey'].DatabaseName);
end;

procedure TMapperTest.WhenAlreadyExistsTheSequenceMappedMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.GetTable(TAutoGeneratedClass);

      Mapper.GetTable(TClassWithSequence);
    end, ESequenceAlreadyExists);

  Mapper.Free;
end;

procedure TMapperTest.WhenANotRequiredPropertyHasTheRequiredAttributeMustMarkTheFieldHasRequired;
begin
  var Table := FMapper.GetTable(TRequiredClass);

  Assert.IsTrue(Table.Field['RequiredObject'].Required);
end;

procedure TMapperTest.WhenAPropertyIsAnArrayMustLoadAManyValueLink;
begin
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(1, Length(Table.ManyValueAssociations));
end;

procedure TMapperTest.WhenAPropertyIsAStringTypeMustBeNotRequired;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.IsFalse(Table.Field['String'].Required);
end;

procedure TMapperTest.WhenATableHasPrimaryKeyThePropertyMustReturnTrue;
begin
  var Table := FMapper.GetTable(TClassWithPrimaryKey);

  Assert.IsTrue(Table.HasPrimaryKey);

  Table := FMapper.GetTable(TClassWithoutPrimaryKey);

  Assert.IsFalse(Table.HasPrimaryKey);
end;

procedure TMapperTest.WhenATableIsLoadedMustFillTheMapperPropertyOfTheTable;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(FMapper, Table.Mapper);
end;

procedure TMapperTest.WhenCallLoadAllMoreThemOneTimeCantRaiseAnError;
begin
  FMapper.LoadAll;

  Assert.WillNotRaise(FMapper.LoadAll);
end;

procedure TMapperTest.WhenCallLoadAllMustLoadAllClassesWithTheEntityAttribute;
begin
  FMapper.LoadAll;

  Assert.IsTrue(Length(FMapper.Tables) > 0, 'No entities loaded!');
end;

procedure TMapperTest.WhenFillTheLazyValueFromAFieldMustLoadTheFieldValueOfTheLazyRecord;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  Table.Field['Lazy'].LazyValue[MyClass] := TLazyLoader.Create(nil, nil, 1234, nil);

  Assert.AreEqual(1234, MyClass.Lazy.LazyValue.Key.AsInteger);

  MyClass.Free;
end;

procedure TMapperTest.WhenFillTheObjectOfALazyFieldMustReturnTheValueWhenGetTheValueAgain;
begin
  var MyClass := TLazyClass.Create;
  var MyEntity := TMyEntity.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  var LazyValue := Table.Field['Lazy'].LazyValue[MyClass];

  LazyValue.Value := MyEntity;

  LazyValue := nil;

  Assert.AreEqual(MyEntity, Table.Field['Lazy'].LazyValue[MyClass].Value.AsObject);

  MyClass.Free;

  MyEntity.Free;
end;

procedure TMapperTest.WhenGetTableByNameAndTheClassNameNotExistsCantRaiseAnyError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable('Invalid Class Name');
    end);
end;

procedure TMapperTest.WhenGetTableByQualifiedNameMustReturnTheTableInformationHasExpected;
begin
  Assert.AreEqual(FMapper.GetTable(TLazyClass), FMapper.GetTable(TLazyClass.QualifiedClassName));
end;

procedure TMapperTest.WhenGetTheLazyValueFromAFieldMustReturnTheInternalInstanceOfTheInterface;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(TLazyClass);

  var LazyValue := Table.Field['Lazy'].LazyValue[MyClass];

  Assert.IsNotNil(LazyValue);

  MyClass.Free;
end;

procedure TMapperTest.WhenGetValueFromANullablePropertyAndTheStoredValueIsFalseMustReturnAnEmptyValue;
begin
  var MyClass := TClassWithNullableProperty.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  MyClass.NullableField := 12345;
  MyClass.NullableFieldStored := False;

  Assert.IsTrue(Table.Field['NullableField'].Value[MyClass].IsEmpty);

  MyClass.Free;
end;

procedure TMapperTest.WhenGetValueOfAndFieldNullableMustReturnEmptyIfHasNoValue;
begin
  var MyClass := TClassWithNullableProperty.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  Assert.IsTrue(Table.Field['Nullable'].Value[MyClass].IsEmpty);

  MyClass.Free;
end;

procedure TMapperTest.WhenLoadAClassMustKeepTheOrderingOfTablesToTheFindTableContinueToWorking;
begin
  FMapper.GetTable(TMyEntity2);

  FMapper.GetTable(TMyEntity);

  FMapper.GetTable(TMyEntity3);

  var Table := FMapper.GetTable(TMyEntity);

  Assert.AreEqual(FContext.GetType(TMyEntity), Table.ClassTypeInfo);
end;

procedure TMapperTest.WhenLoadAFieldMustFillThePropertyWithThePropertyInfo;
begin
  var Table := FMapper.GetTable(TMyEntity3);
  var TypeInfo := FContext.GetType(TMyEntity3).GetProperties[0];

  Assert.AreEqual(TypeInfo, Table.Fields[0].PropertyInfo);
end;

procedure TMapperTest.WhenLoadAFieldMustLoadTheFieldTypeWithTheTypeOfTheProperty;
begin
  var IntegerType := FContext.GetType(TypeInfo(Integer));
  var Table := FMapper.GetTable(TClassWithNullableProperty);

  Assert.AreEqual(IntegerType, Table.Fields[0].FieldType);
end;

procedure TMapperTest.WhenLoadALazyFieldMustLoadTheLazyTypeInfoAsExpected;
begin
  var Table := FMapper.GetTable(TLazyClass);

  Assert.IsNotNil(Table.Field['Lazy'].LazyType);

  Assert.AreEqual(TypeInfo(TMyEntity), Table.Field['Lazy'].LazyType.Handle);
end;

procedure TMapperTest.WhenLoadAnInheritedTableTheAllFieldCountPropertyMustCountTheFieldFromBaseClassesToo;
begin
  var Table := FMapper.GetTable(TClassLevel4);

  Assert.AreEqual(6, Table.AllFieldCount);
end;

procedure TMapperTest.WhenLoadAnInheritedTableTheFieldIndexMustBaseAdjustedToTheCountOfFieldInTheBaseClass;
begin
  var Table := FMapper.GetTable(TClassLevel4);

  Assert.AreEqual(2, Table.Field['Field4'].Index);
  Assert.AreEqual(3, Table.Field['Field3'].Index);
  Assert.AreEqual(4, Table.Field['Field2'].Index);
  Assert.AreEqual(5, Table.Field['Id'].Index);
end;

procedure TMapperTest.WhenLoadAnInheritedTableThePrimaryKeyFieldCantBeAutoGenerated;
begin
  var Table := FMapper.GetTable(TClassLevel4);

  Assert.IsFalse(Table.PrimaryKey.AutoGenerated);
end;

procedure TMapperTest.WhenLoadATableWithInheritenceWithoutAnyFieldsCantRaiseLoadError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable(TMyClassInheritedWithoutFields);
    end);
end;

procedure TMapperTest.WhenLoadATableWithMoreThenOneLevelWithSingleInheritenceMustLoadTheFieldsAsExpected;
begin
  var TableLevel1 := FMapper.GetTable(TClassLevel1);
  var TableLevel4 := FMapper.GetTable(TClassLevel4);

  Assert.AreEqual(2, Length(TableLevel1.Fields));
  Assert.AreEqual(4, Length(TableLevel4.Fields));
end;

procedure TMapperTest.WhenLoadANullableFieldMustLoadTheFieldTypeWithTheInternalNullableType;
begin
  var IntegerType := FContext.GetType(TypeInfo(Integer));
  var Table := FMapper.GetTable(TClassWithNullableProperty);

  Assert.AreEqual(IntegerType, Table.Field['Nullable'].FieldType);
end;

procedure TMapperTest.WhenLoadATableMustLoadAllFieldsCountWithTheTotalFieldOfTheTable;
begin
  var Table := FMapper.GetTable(TClassLevel1);

  Assert.AreEqual(2, Table.AllFieldCount);
end;

procedure TMapperTest.WhenLoadATableMustLoadAllFieldsToo;
begin
  var Table := FMapper.GetTable(TMyEntity);

  Assert.AreEqual(3, Length(Table.Fields));
end;

procedure TMapperTest.WhenLoadATableWithSingleInheritenceMustLoadTheFieldsOfAllLevels;
begin
  Assert.AreEqual(4, Length(FMapper.GetTable(TAnotherSingleInheritedConcrete).Fields));
end;

procedure TMapperTest.WhenLoadMoreThenOneTimeTheSameClassCantRaiseAnError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable(TMyEntity);

      FMapper.GetTable(TMyEntity);
    end);
end;

procedure TMapperTest.WhenLoadTheFieldOfATableMustLoadTheNameOfTheFieldWithThePropertyName;
begin
  var Table := FMapper.GetTable(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual('Name', Table.Fields[0].Name);
end;

procedure TMapperTest.WhenLoadTheIndexMustLoadTheNameOfTheIndexHasExpected;
begin
  var Table := FMapper.GetTable(TMyClassWithIndex);

  Assert.AreEqual('MyIndex', Table.Indexes[1].DatabaseName);
  Assert.AreEqual('MyIndex2', Table.Indexes[2].DatabaseName);
  Assert.AreEqual('MyUnique', Table.Indexes[3].DatabaseName);
end;

procedure TMapperTest.WhenLoadTheSchemaMustLoadAllClassesFromTheUnitsPassedInTheParams;
begin
  FMapper.LoadAll([TMyClass, TMyTestClass]);

  Assert.IsNotNil(FMapper.GetTable(TMyClass));

  Assert.IsNotNil(FMapper.GetTable(TMyTestClass));

  Assert.IsNotNil(FMapper.GetTable(TClassWithPrimaryKeyAttribute));
end;

procedure TMapperTest.WhenLoadTheSchemaWithAClassInParamsTheMapperMustLoadOnlyTheClassesInTheUnitOfThatClass;
begin
  FMapper.LoadAll([TMyClass]);

  Assert.AreEqual(81, Length(FMapper.Tables));
end;

procedure TMapperTest.WhenLoadTheTableMustLoadTheNameOfTheTableWithTheNameOfTheClassWithoutTheTChar;
begin
  var Table := FMapper.GetTable(TMyEntity2);

  Assert.AreEqual('MyEntity2', Table.Name);
end;

procedure TMapperTest.WhenMapAForeignKeyIsToAClassWithoutAPrimaryKeyMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      FMapper.GetTable(TMyEntityForeignKeyToClassWithoutPrimaryKey);
    end, EClassWithoutPrimaryKeyDefined);
end;

procedure TMapperTest.WhenMappingALazyArrayClassCantRaiseAnyError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable(TLazyArrayClass);
    end);
end;

procedure TMapperTest.WhenMappingALazyArrayClassMustLoadTheFieldWithTheExpectedPropertyValueFilled;
begin
  var Table := FMapper.GetTable(TLazyArrayClass);

  var Field := Table['LazyArray'];

  Assert.IsFalse(Field.IsForeignKey, 'Not a foreign key');

  Assert.IsTrue(Field.IsManyValueAssociation, 'Is many value association');

  Assert.IsTrue(Field.IsLazy, 'Is lazy');
end;

procedure TMapperTest.WhenSetTheFieldValueAndTheFieldIsLazyMustReturnTheValueFilled;
begin
  var MyClass := TLazyClass.Create;
  var MyEntity := TMyEntity.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  var LazyField := Table.Field['Lazy'];

  LazyField.Value[MyClass] := MyEntity;

  Assert.AreEqual(MyEntity, LazyField.Value[MyClass].AsObject);

  MyClass.Free;

  MyEntity.Free;
end;

procedure TMapperTest.WhenTheAttributeIsASequenceMustLoadTheNameOfTheSequenceInTheDefaultConstraint;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual('MySequence', Table.Field['Sequence'].DefaultConstraint.Sequence.Name);
end;

procedure TMapperTest.WhenTheChildClassIsDeclaredBeforeTheParentClassTheLinkBetweenOfTablesMustBeCreated;
begin
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(1, Length(Table.ManyValueAssociations));
end;

procedure TMapperTest.WhenTheClassHasAForeignKeyAndTheKeyTableIsntLoadedMustLoadTheTableFirstAndNotRaiseAnError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable(TMyEntityForeignKeyAlias);
    end);
end;

procedure TMapperTest.WhenTheClassHasAnArrayWithTypeNotEqualToObjectCanLoadTheManyValueFromThisProperty;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable(TMyClassWithByteArray);
    end);

  Assert.AreEqual(0, Length(FMapper.GetTable(TMyClassWithByteArray).ManyValueAssociations));
end;

procedure TMapperTest.WhenTheClassHasASimpleInheritenceMustLoadTheBaseTableProperty;
begin
  var Table := FMapper.GetTable(TMyEntityInheritedFromSimpleClass);

  Assert.AreEqual(FMapper.GetTable(TMyEntityInheritedFromSingle), Table.BaseTable);
end;

procedure TMapperTest.WhenTheClassHasntPublishedFieldsMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      FMapper.GetTable(TMyClassWithoutPublishedFields);
    end, ETableWithoutPublishedFields);
end;

procedure TMapperTest.WhenTheClassHasTheIndexAnnotationMustLoadTheIndexInfoOfTheTable;
begin
  var Table := FMapper.GetTable(TMyClassWithIndex);

  Assert.AreEqual(4, Length(Table.Indexes));
end;

procedure TMapperTest.WhenTheClassHaveThePrimaryKeyAttributeThePrimaryKeyWillBeTheFieldFilled;
begin
  var Table := FMapper.GetTable(TMyEntityWithPrimaryKey);

  Assert.AreEqual('Value', Table.PrimaryKey.DatabaseName);
end;

procedure TMapperTest.WhenTheClassHaveTheTableNameAttributeTheDatabaseNameMustBeLikeTheNameInAttribute;
begin
  var Table := FMapper.GetTable(TMyEntity2);

  Assert.AreEqual('AnotherTableName', Table.DatabaseName);
end;

procedure TMapperTest.WhenTheClassInheritsFromObjectCantRaiseAnyError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      FMapper.GetTable(TZZZZ);
    end);
end;

procedure TMapperTest.WhenTheClassIsInheritedFromANormalClassCantLoadFieldsFormTheBaseClass;
begin
  Assert.AreEqual(2, Length(FMapper.GetTable(TMyEntityInheritedFromSimpleClass).Fields));
end;

procedure TMapperTest.WhenTheClassIsInheritedFromANormalClassMustCreateAForeignKeyForTheBaseClass;
begin
  Assert.AreEqual(1, Length(FMapper.GetTable(TMyEntityInheritedFromSimpleClass).ForeignKeys));
end;

procedure TMapperTest.WhenTheClassIsInheritedFromTObjectCantCreateAForeignKeyForThatClass;
begin
  Assert.AreEqual(0, Length(FMapper.GetTable(TMyEntity).ForeignKeys));
end;

procedure TMapperTest.WhenTheClassIsInheritedMustLoadThePrimaryKeyFromBaseClass;
begin
  var Table := FMapper.GetTable(TMyEntityInheritedFromSimpleClass);

  Assert.IsTrue(Assigned(Table.PrimaryKey));
end;

procedure TMapperTest.WhenTheFieldHasFieldInfoAttributeWithSpecialTypeFilledMustLoadThisInfoInTheField;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stUniqueIdentifier, Table.Field['UniqueIdentifier'].SpecialType);
end;

procedure TMapperTest.WhenTheFieldAsTheSequenceAttributeMustLoadTheSequenceInTheList;
begin
  var Mapper := TMapper.Create;

  Mapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual(1, Length(Mapper.Sequences));

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasAForeignKeyToASpecialFieldTheSpecialTypeOfTheFieldMustBeEqualToThePrimaryKeyOfForeignKeyClass;
begin
  var Table := FMapper.GetTable(TForeignKeyClassToSpecialCase);

  Assert.AreEqual(stDateTime, Table.Field['DateTimeForeignKey'].SpecialType)
end;

procedure TMapperTest.WhenTheFieldHasFieldInfoAttributeWithPrecisionAndScaleFilledMustLoadThisInfoInTheField;
begin
  var Table := FMapper.GetTable(TMyTestClass);

  Assert.AreEqual(15, Table.Fields[2].Size);
  Assert.AreEqual(7, Table.Fields[2].Scale);
end;

procedure TMapperTest.WhenTheFieldHasFieldInfoAttributeWithSizeFilledMustLoadThisInfoInTheField;
begin
  var Table := FMapper.GetTable(TMyTestClass);

  Assert.AreEqual(150, Table.Fields[1].Size);
end;

procedure TMapperTest.WhenTheFieldHasTheBinaryAttributeMustLoadTheSpecialTypeAsExpected;
begin
  var Table := FMapper.GetTable(TMyClassWithAllFieldsType);

  Assert.AreEqual(stBinary, Table.Field['BinaryField'].SpecialType);
end;

procedure TMapperTest.WhenTheFieldHasTheFixedValueAttributeMustLoadTheValueInTheDefaultConstraint;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.AreEqual('''MyValue''', Table.Field['FixedValue'].DefaultConstraint.FixedValue);
end;

procedure TMapperTest.WhenTheFieldHaveTheFieldNameAttributeMustLoadThisNameInTheDatabaseName;
begin
  var Table := FMapper.GetTable(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual('AnotherFieldName', Table.Fields[0].DatabaseName);
end;

procedure TMapperTest.WhenTheFieldIsAClassMustFillTheDatabaseNameWithIdPlusPropertyName;
begin
  var Table := FMapper.GetTable(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual('IdMyForeignKey', Table.Field['MyForeignKey'].DatabaseName);
end;

procedure TMapperTest.WhenTheFieldIsAClassMustMarkAsNotRequired;
begin
  var Table := FMapper.GetTable(TMyEntityForeignKeyAlias);

  Assert.IsFalse(Table.Field['ForeignKey'].Required);
end;

procedure TMapperTest.WhenTheFieldIsAForeignKeyMustAppendTheIdInTheDatabaseNameOfTheField;
begin
  var Table := FMapper.GetTable(TLazyClass);

  Assert.AreEqual('IdLazy', Table.Field['Lazy'].DatabaseName);
end;

procedure TMapperTest.WhenTheFieldIsLazyLoadingAndTheValueIsntLoadedMustReturnEmptyValueInParam;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue := 123;

  Table.Field['Lazy'].HasValue(MyClass, Value);

  Assert.IsTrue(Value.IsEmpty);

  MyClass.Free;
end;

procedure TMapperTest.WhenTheFieldIsLazyLoadingAndTheValueIsntLoadedMustReturnFalseInTheFunction;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Assert.IsFalse(Table.Field['Lazy'].HasValue(MyClass, Value));

  MyClass.Free;
end;

procedure TMapperTest.WhenTheFieldIsBinaryCantBeRequiredByDefault;
begin
  var Table := FMapper.GetTable(TMyClassWithAllFieldsType);

  Assert.IsFalse(Table.Field['BinaryField'].Required);
end;

procedure TMapperTest.WhenTheFieldIsBooleanTypeMustLoadTheSpecialTypeWithBoolean;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stBoolean, Table.Field['Boolean'].SpecialType);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldIsManyValueAssociationMustLoadTheManyValuePropertyOfTheField;
begin
  var Table := FMapper.GetTable(TMyEntityWithManyValueAssociation);

  var Field := Table.Field['ManyValueAssociationList'];

  Assert.IsNotNil(Field.ManyValueAssociation);
end;

procedure TMapperTest.WhenTheFieldIsMappedMustLoadTheReferenceToTheTableOfTheField;
begin
  var Table := FMapper.GetTable(TMyEntity);

  Assert.AreEqual(Table, Table.Fields[0].Table);
end;

procedure TMapperTest.WhenTheFieldIsntAutoGeneratedTheDefaultConstraintMustBeNil;
begin
  var Table := FMapper.GetTable(TAutoGeneratedClass);

  Assert.IsNil(Table.Field['Value'].DefaultConstraint);
end;

procedure TMapperTest.WhenTheFieldIsntFoundMustRaiseAnError;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.WillRaise(
    procedure
    begin
      Table.Field['AnotherFieldInvalid'];
    end, EFieldNotFound);
end;

procedure TMapperTest.WhenTheFieldIsOfDateTimeTypeMustLoadTheSpecialTypeWithDateTime;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stDateTime, Table.Field['DateTime'].SpecialType);
end;

procedure TMapperTest.WhenTheFieldIsOfDateTypeMustLoadTheSpecialTypeWithDate;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stDate, Table.Field['Date'].SpecialType);
end;

procedure TMapperTest.WhenTheFieldIsOfTimeTypeMustLoadTheSpecialTypeWithTime;
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stTime, Table.Field['Time'].SpecialType);
end;

procedure TMapperTest.WhenTheFieldIsRequiredMustLoadThisInfoInTheField;
begin
  var Table := FMapper.GetTable(TRequiredClass);

  var Field := Table.Field['RequiredField'];

  Assert.IsTrue(Field.Required);
end;

procedure TMapperTest.WhenTheFieldsAreLoadedMustFillTheNameWithTheNameOfPropertyOfTheClass;
begin
  var Table := FMapper.GetTable(TMyEntity3);

  Assert.AreEqual('Id', Table.Fields[0].DatabaseName);
end;

procedure TMapperTest.WhenTheForeignKeyIsAClassAliasMustLoadTheForeignClassAndLinkToForeignKey;
begin
  var Table := FMapper.GetTable(TMyEntityWithForeignKeyAlias);

  Assert.AreEqual(1, Length(Table.ForeignKeys));
end;

procedure TMapperTest.WhenTheForeignKeyIsCreatesMustLoadTheParentTable;
begin
  var Table := FMapper.GetTable(TMyEntityWithFieldNameAttribute);

  Assert.IsNotNil(Table.ForeignKeys[0].ParentTable);
end;

procedure TMapperTest.WhenTheForeignKeyTableHasAFloatKeyMustLoadThePrecisionAndSizeFromThePrimaryKey;
begin
  var Table := FMapper.GetTable(TForeignKeyClassToSpecialCase);

  Assert.AreEqual(20, Table.Field['FloatForeignKey'].Size);
  Assert.AreEqual(5, Table.Field['FloatForeignKey'].Scale);
end;

procedure TMapperTest.WhenTheLazyFieldIsntChangedCantRaiseAnyErrorWhenTryToGetTheLazyValue;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Assert.WillNotRaise(
    procedure
    begin
      Table.Field['Lazy'].HasValue(MyClass, Value);
    end);

  MyClass.Free;
end;

procedure TMapperTest.WhenTheLazyFieldIsntLoadedAndHaveAKeyFilledMustReturnTheKeyValueInGetValueFunction;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  Table.Field['Lazy'].LazyValue[MyClass] := TLazyLoader.Create(nil, nil, 1234, nil);

  Assert.AreEqual(1234, Table.Field['Lazy'].Value[MyClass].AsInteger);

  MyClass.Free;
end;

procedure TMapperTest.WhenTheLazyPropertyIsLoadedMustReturnTheInternalValue;
begin
  var MyClass := TLazyClass.Create;
  var TheClass := TMyEntity.Create;

  MyClass.Lazy.Value := TheClass;

  var Table := FMapper.GetTable(TLazyClass);
  var Field := Table.Field['Lazy'];

  Assert.AreEqual(TheClass, Field.Value[MyClass].AsObject);

  MyClass.Free;

  TheClass.Free;
end;

procedure TMapperTest.WhenTheLazyValueHasOnlyTheKeyLoadedMustReturnTrueInTheFieldValue;
begin
  var MyClass := TLazyClass.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);
  var Value: TValue;

  Table.Field['Lazy'].LazyValue[MyClass] := TLazyLoader.Create(nil, nil, 1234, nil);

  Assert.IsTrue(Table.Field['Lazy'].HasValue(MyClass, Value));

  MyClass.Free;
end;

procedure TMapperTest.WhenTheLinkBetweenTheManyValueAssociationAndTheChildTableForeignKeyDontExistsMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      FMapper.GetTable(TManyValueAssociationParentNoLink);
    end, EManyValueAssociationLinkError);
end;

procedure TMapperTest.WhenTheNullablePropertyIsFilledWithAValueMustLoadTheValue;
begin
  var MyClass := TClassWithNullableProperty.Create;
  var Table := FMapper.GetTable(MyClass.ClassType);

  var Field := Table.Fields[1];

  Field.Value[MyClass] := 123456;

  Assert.AreEqual(123456, MyClass.Nullable);

  MyClass.Free;
end;

procedure TMapperTest.WhenTheNullablePropertyIsLoadedMustReturnTheFilled;
begin
  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Nullable := 123456;
  var Table := FMapper.GetTable(MyClass.ClassType);

  var Field := Table.Field['Nullable'];

  Assert.AreEqual(123456, Field.Value[MyClass].AsInteger);

  MyClass.Free;
end;

procedure TMapperTest.WhenThePropertyIsANativeTypeMustMarkTheFieldAsRequired(const FieldName: String);
begin
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.IsTrue(Table.Field[FieldName].Required, FieldName);
end;

procedure TMapperTest.WhenThePropertyIsLazyMustCreateTheForeignKeyToThisProperty;
begin
  var Table := FMapper.GetTable(TLazyClass);

  Assert.AreEqual(1, Length(Table.ForeignKeys));
end;

procedure TMapperTest.WhenThePropertyIsLazyMustFillWithTrueTheIsLazyPropertyInTheField;
begin
  var Table := FMapper.GetTable(TLazyClass);

  Assert.IsTrue(Table.Field['Lazy'].IsLazy);
end;

procedure TMapperTest.WhenThePropertyIsLazyMustReturnTheFieldTypeWithTheInternalLazyType;
begin
  var Table := FMapper.GetTable(TLazyClass);

  Assert.AreEqual(FContext.GetType(TypeInfo(Integer)), Table.Field['Lazy'].FieldType);
end;

procedure TMapperTest.WhenThePropertyIsNullableMustMarkTheFieldAsNotRequired;
begin
  var Table := FMapper.GetTable(TClassWithNullableProperty);

  Assert.IsFalse(Table.Field['NullableField'].Required);
  Assert.IsFalse(Table.Field['NullableProcedure'].Required);
end;

procedure TMapperTest.WhenTheTableHasAPrimaryKeyMustCreateAnIndexForThePrimaryKey;
begin
  var Table := FMapper.GetTable(TClassWithPrimaryKey);

  Assert.AreEqual(1, Length(Table.Indexes));
end;

procedure TMapperTest.WhenTheTableIsInheritedMustLoadAllManyValueAssociationOfTheClass;
begin
  Assert.AreEqual(1, Length(FMapper.GetTable(TManyValueClassInherited).ManyValueAssociations));
end;

procedure TMapperTest.WhenTryToFindAFieldMustIgnoreTheFieldNameCase;
begin
  var Field: TField := nil;
  var Table := FMapper.GetTable(TMyEntityWithAllTypeOfFields);

  Assert.WillNotRaise(
    procedure
    begin
      Field := Table.Field['uniqueidentifier'];
    end);

  Assert.IsNotNil(Field);

  Assert.AreEqual('UniqueIdentifier', Field.Name);
end;

procedure TMapperTest.WhenTryToFindATableMustReturnTheTableOfTheClass;
begin
  var Table := FMapper.GetTable(TMyEntity3);

  Assert.AreEqual(TMyEntity3, Table.ClassTypeInfo.MetaclassType);
end;

procedure TMapperTest.WhenUseTheUniqueIndexAttributeMustMarkTheIndexAsUnique;
begin
  var Table := FMapper.GetTable(TMyClassWithIndex);

  Assert.IsTrue(Table.Indexes[3].IsUnique);
end;

end.

