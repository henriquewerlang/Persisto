unit Persisto.Manager.Test;

interface

uses System.Generics.Collections, Data.DB, Test.Insight.Framework, Persisto, Persisto.Mapping;

type
  [TestFixture]
  TManagerTest = class
  private
    FConnection: IDatabaseConnection;
    FGarbage: TList<TObject>;
    FManager: TPersistoManager;

    function CreateObject<T: class, constructor>: T;

    procedure PrepareDatabase;
  public
    [Setup]
    procedure Setup;
    [TearDown]
    procedure TearDown;
    [Test]
    procedure WhenInsertAValueInManagerMustInsertTheValueInDatabaseAsExpected;
    [Test]
    procedure WhenInsertAnObjectWithAutoGeneratedValuesMustLoadTheValueInTheInsertedObject;
    [Test]
    procedure BeforeSaveTheMainObjectMustSaveTheForeignKeysOfTheObject;
    [Test]
    procedure WhenInsertAnObjectTheObjectsMustBeProcessedOnlyOneTime;
    [Test]
    procedure WhenAClassIsInheritedFromAnotherClassMustInsertTheParentClassInTheInsert;
    [Test]
    procedure WhenInsertAnObjectWithForeignKeyMustInsertTheForeignKeyPrimaryKeyValueInTheCurrentObject;
    [Test]
    procedure WhenUpdateAnObjectMustUpdateTheChangedFieldsOfTheObject;
    [Test]
    procedure WhenUpdateAnObjectMustUpdateOnlyTheObjectCallInTheProcedure;
    [Test]
    procedure WhenUpdateAnObjectMustUpdateOnlyTheChangedFieldsOfTheObject;
    [Test]
    procedure WhenUpdateAnInheritedObjectMustUpdateAllClassLevelsToo;
    [Test]
    procedure WhenChangeTheForeignKeyOfTheObjectMustUpdateTheForeignKeyValueFromTheCurrentTable;
    [Test]
    procedure WhenTryToUpdateAForeignObjectMustRaiseErrorExplainingThisNotAllowed;
    [Test]
    procedure WhenUpdateAnObjectWithoutChangesCanRaiseAnyUpdateError;
    [Test]
    procedure WhenUpdateAnObjectMustUpdateTheForeignKeyOfTheObjectToo;
    [Test]
    procedure WhenInsertAClassThatIsRecursiveInItSelfCantRaiseErrorOfStackOverflow;
    [Test]
    procedure WhenUpdateAClassThatIsRecursiveInItSelfCantRaiseErrorOfStackOverflow;
    [Test]
    procedure WhenInsertAnObjectWithRecursionAndTheForeignKeyIsntRequiredMustDelayTheInsertionOfForeignKeyToGetTheKeyInsertedAndUpdateTheColumnValue;
    [Test]
    procedure WhenInsertAnObjectWithEmptyForeignKeysCantRaiseAnyError;
    [Test]
    procedure WhenInsertARecursiveRequiredObjectMustInsertTheForeignKeyFirstToInsertTheMainObject;
    [Test]
    procedure WhenSaveAnObjectThatWasntInsertedMustInsertTheObject;
    [Test]
    procedure WhenSaveAnObjectThatAlreadyInTheDatabaseMustUpdateTheFieldsOfTheObject;
    [Test]
    procedure WhenInsertAnObjectMustUpdateTheForeignKeyValues;
    [Test]
    procedure WhenUpdateAnObjectMustInsertTheNewObjectInTheForeignKey;
    [Test]
    procedure WhenInsertAnObjectWithManyValueAssociationCanRaiseAnyError;
    [Test]
    procedure WhenInsertAnObjectWithManyValueAssociationMustInsertTheChildValues;
    [Test]
    procedure WhenInsertAnObjectWithManyValueAssociationMustUpdateTheParentForeignKeyValueInTheChildTable;
    [Test]
    procedure WhenUpdateAnObjectWithManyValueAssociationCantRaiseAnyError;
    [Test]
    procedure WhenUpdateAnObjectWithManyValueAssociationMustUpdateTheChildValues;
    [Test]
    procedure WhenUpdateAnObjectWithManyValueAssociationMustInsertTheNewChildValues;
    [Test]
    procedure WhenLoadAnObjectWithOrderByMustLoadTheObjectsInTheOrderAsExpected;
    [Test]
    procedure WhenTheOrderByHasMoreThenOneFieldMustExecuteAsExpected;
    [Test]
    procedure WhenFilterAFieldMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithLessThanOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithLessThanOrEqualOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithGreaterThanOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithGreaterThanOrEqualOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithNotEqualOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithBetweenOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterWithBitwiseAndOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterWithBitwiseOrOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenMixBitwiseOrAndTheBitwiseAndOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithLikeOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithIsNullOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithLogicalNotOperatorMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithComplexFieldNameMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAFieldWithComplexFieldNameInManyValueAssociationLinkMustReturnTheObjectsInTheFilterAsExpected;
    [Test]
    procedure WhenFilterAComplexFieldFromAnInheritedTableMustReturnTheObjectAsExpected;
    [Test]
    procedure WhenFilterAInheritedFieldMustFilterByThisField;
    [Test]
    procedure WhenTheOrderByClauseHasAComplexFieldNameMustFindTheFieldAndApplyInTheOrderByList;
    [Test]
    procedure WhenDontFindTheFieldInTheWhereClauseMustRaiseAnError;
    [Test]
    procedure WhenDontFindTheFieldInTheOrderByClauseMustRaiseAnError;
    [Test]
    procedure WhenSelectAnObjectUsingAForeignKeyFieldMustFindAndFilterTheTableByThisField;
    [Test]
    procedure WhenTheOrderByClauseAsAnForeignKeyObjectTheOrderByMustBeOrderAsExpected;
    [Test]
    procedure WhenInsertAManyValueAssociationClassWithALazyForeignKeyMustInsertTheChildObjectsWithTheLinkToTheParentClassFilled;
    [Test]
    procedure WhenLoadALazyManyValueAssociationTheLoadOfChildObjectsMustBeDelayed;
    [Test]
    procedure WhenLoadALazyManyValueAssociationMustLoadAllChildsAsExpected;
    [Test]
    procedure WhenSaveAnObjectMoreThenOnceItMustBeSavedOnlyOnceInTheDatabase;
    [Test]
    procedure WhenSaveAnObjectThatDontExistsInDatabaseCantRaiseForiegnObjectException;
    [Test]
    procedure WhenSaveAnObjectThatDontExistsInDatabaseMustInsertThisObject;
    [Test]
    procedure WhenUpdateAnObjectThatDontExistsInDatabaseMustRaiseForeignObjectException;
    [Test]
    procedure WhenUpdateAnObjectThatExistsInDatabaseCantRaiseForeignObjectException;
    [Test]
    procedure WhenUpdateAnObjectThatExistsInDatabaseMustLoadTheObjectStatusAndUpdateTheValuesInDatabase;
    [Test]
    procedure WhenUpdateAnObjectThatExistsInDatabaseAndHaveManyValueAssociationCantRaiseDatabaseError;
    [Test]
    procedure WhenGetTheFieldValueFromALazyArrayMustReturnTheArrayInTheValueOfTheField;
    [Test]
    procedure WhenUpdateALazyClassCantRaiseAnyError;
    [Test]
    procedure WhenSaveMustSaveAllTheObjectsInTheList;
    [Test]
    procedure WhenSaveAnObjectMustStartAnTransactionAndIfIsRaisedAnErrorMustRollback;
    [Test]
    procedure WhenInsertMustInsertAllTheObjectsInTheArray;
    [Test]
    procedure WhenInsertAnObjectMustStartAnTransactionAndIfRaiseAnErrorMustRollback;
    [Test]
    procedure WhenUpdateMustUpdateAllTheObjectsInTheArray;
    [Test]
    procedure WhenUpdateAnObjectMustStartAnTransactionAndIfRaiseAnErrorMustRollback;
    [Test]
    procedure WhenInsertingAnUnloadedLazyFieldMustInsertTheKeyValueFromLazyField;
    [Test]
    procedure WhenUpdatintAnUnloadedLazyFieldMustUpdateTheKeyValueFromLazyField;
    [Test]
    procedure WhenUseALazyFieldInTheFieldMustLoadTheJoinForTheFilterWorks;
    [Test]
    procedure WhenRemoveAnObjectMustDeleteTheRecordFromDatabase;
    [Test]
    procedure WhenRemoveAnObjectMustStartATransaction;
    [Test]
    procedure WhenDeleteAnObjectMustRemoveOnlyThisObject;
  end;

  TDatabaseConnectionMock = class(TInterfacedObject, IDatabaseConnection)
  private
    FConnection: IDatabaseConnection;
    FLastCommandExecuted: String;

    function GetDatabaseName: String;
    function PrepareCursor(const SQL: String; const Params: TParams): IDatabaseCursor;
    function OpenCursor(const SQL: String): IDatabaseCursor;
    function StartTransaction: TDatabaseTransaction;

    procedure ExecuteDirect(const SQL: String);
    procedure ExecuteScript(const Script: String);
    procedure SetDatabaseName(const Value: String);
  public
    constructor Create(const Connection: IDatabaseConnection);

    property LastCommandExecuted: String read FLastCommandExecuted write FLastCommandExecuted;
  end;

  [TestFixture]
  TManagerDatabaseManipulationTest = class
  private
    FManager: TPersistoManager;
  public
    [Setup]
    procedure Setup;
    [TearDown]
    procedure TearDown;
    [Test]
    procedure WhenUpdateTheDatabaseCantRaiseAnyError;
    [Test]
    procedure WhenUpdateTheDatabaseMustCreateTheTablesAfterTheProcessEnd;
  end;

implementation

uses System.SysUtils, System.Variants, System.Rtti, System.TypInfo, Persisto.Test.Entity, Persisto.Test.Connection;

{ TManagerTest }

procedure TManagerTest.BeforeSaveTheMainObjectMustSaveTheForeignKeysOfTheObject;
begin
  var MainObject := CreateObject<TInsertTestWithForeignKey>;
  MainObject.FK1 := CreateObject<TInsertAutoGeneratedSequence>;

  FManager.Insert([MainObject]);

  var Cursor := FManager.OpenCursor('select * from InsertAutoGeneratedSequence');

  Assert.IsTrue(Cursor.Next);
end;

function TManagerTest.CreateObject<T>: T;
begin
  Result := T.Create;

  FGarbage.Add(Result);
end;

procedure TManagerTest.PrepareDatabase;

  procedure InsertData;
  begin
    var Object1 := CreateObject<TMyEntityWithoutEntityAttribute>;
    Object1.Id := 20;
    Object1.Name := 'Name';
    Object1.Value := 111.222;

    FManager.Insert([Object1]);

    var AAAAObject: TAAAA;
    var ClassLevel4: TClassLevel4;
    var LazyArrayClass: TLazyArrayClass;
    var NullObject: TClassWithNullableProperty;
    var WithForeignKey: TInsertTestWithForeignKey;

    AAAAObject := CreateObject<TAAAA>;
    AAAAObject.Id := 1;
    AAAAObject.Value := 'AAA';

    FManager.Insert([AAAAObject]);

    AAAAObject := CreateObject<TAAAA>;
    AAAAObject.Id := 5;
    AAAAObject.Value := 'AAA';

    FManager.Insert([AAAAObject]);

    AAAAObject := CreateObject<TAAAA>;
    AAAAObject.Id := 10;
    AAAAObject.Value := 'AAA';

    FManager.Insert([AAAAObject]);

    AAAAObject := CreateObject<TAAAA>;
    AAAAObject.Id := 3;
    AAAAObject.Value := 'BBB';

    FManager.Insert([AAAAObject]);

    AAAAObject := CreateObject<TAAAA>;
    AAAAObject.Id := 8;
    AAAAObject.Value := 'BBB';

    FManager.Insert([AAAAObject]);

    NullObject := CreateObject<TClassWithNullableProperty>;
    NullObject.Id := 1;

    FManager.Insert([NullObject]);

    NullObject := CreateObject<TClassWithNullableProperty>;
    NullObject.Id := 2;
    NullObject.Nullable := 20;

    FManager.Insert([NullObject]);

    var ManyObject := CreateObject<TMyManyValue>;
    ManyObject.Childs := [CreateObject<TMyChildLink>, CreateObject<TMyChildLink>, CreateObject<TMyChildLink>];
    ManyObject.Childs[0].ManyValueAssociation := CreateObject<TMyEntityWithManyValueAssociation>;
    ManyObject.Childs[0].ManyValueAssociation.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>, CreateObject<TMyEntityWithManyValueAssociationChild>];
    ManyObject.Childs[0].ManyValueAssociation.ManyValueAssociationList[0].Value := 30;
    ManyObject.Childs[0].ManyValueAssociation.ManyValueAssociationList[1].Value := 20;
    ManyObject.Childs[1].ManyValueAssociation := CreateObject<TMyEntityWithManyValueAssociation>;
    ManyObject.Childs[1].ManyValueAssociation.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>];
    ManyObject.Childs[1].ManyValueAssociation.ManyValueAssociationList[0].Value := 40;
    ManyObject.Childs[2].ManyValueAssociation := CreateObject<TMyEntityWithManyValueAssociation>;
    ManyObject.Childs[2].ManyValueAssociation.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>, CreateObject<TMyEntityWithManyValueAssociationChild>, CreateObject<TMyEntityWithManyValueAssociationChild>];
    ManyObject.Childs[2].ManyValueAssociation.ManyValueAssociationList[0].Value := 50;
    ManyObject.Childs[2].ManyValueAssociation.ManyValueAssociationList[1].Value := 10;
    ManyObject.Childs[2].ManyValueAssociation.ManyValueAssociationList[2].Value := 60;

    FManager.Insert([ManyObject]);

    var ManyValueInherited := [CreateObject<TManyValueParentInherited>, CreateObject<TManyValueParentInherited>];
    ManyValueInherited[0].Childs := [CreateObject<TManyValueChildInherited>];
    ManyValueInherited[0].Childs[0].Id := 45;
    ManyValueInherited[0].Childs[0].Value := CreateObject<TClassWithPrimaryKey>;
    ManyValueInherited[0].Childs[0].Value.Id := 11;
    ManyValueInherited[0].Childs[0].Value.Value := 25;
    ManyValueInherited[0].Id := 10;
    ManyValueInherited[1].Childs := [CreateObject<TManyValueChildInherited>];
    ManyValueInherited[1].Childs[0].Id := 15;
    ManyValueInherited[1].Childs[0].Value := CreateObject<TClassWithPrimaryKey>;
    ManyValueInherited[1].Childs[0].Value.Id := 22;
    ManyValueInherited[0].Childs[0].Value.Value := 35;
    ManyValueInherited[1].Id := 20;

    FManager.Insert(TArray<TObject>(ManyValueInherited));

    ClassLevel4 := CreateObject<TClassLevel4>;
    ClassLevel4.Field1 := 'abc';
    ClassLevel4.Field2 := 'efg';
    ClassLevel4.Field3 := 'hij';
    ClassLevel4.Field4 := 'klm';
    ClassLevel4.Id := 1;

    FManager.Insert([ClassLevel4]);

    ClassLevel4 := CreateObject<TClassLevel4>;
    ClassLevel4.Field1 := 'aaa';
    ClassLevel4.Field2 := 'bbb';
    ClassLevel4.Field3 := 'ccc';
    ClassLevel4.Field4 := 'ddd';
    ClassLevel4.Id := 2;

    FManager.Insert([ClassLevel4]);

    WithForeignKey := CreateObject<TInsertTestWithForeignKey>;
    WithForeignKey.FK1 := CreateObject<TInsertAutoGeneratedSequence>;
    WithForeignKey.FK1.Value := 20000;

    FManager.Insert([WithForeignKey]);

    WithForeignKey := CreateObject<TInsertTestWithForeignKey>;
    WithForeignKey.FK1 := CreateObject<TInsertAutoGeneratedSequence>;
    WithForeignKey.FK1.Value := 30000;

    FManager.Insert([WithForeignKey]);

    WithForeignKey := CreateObject<TInsertTestWithForeignKey>;
    WithForeignKey.FK1 := CreateObject<TInsertAutoGeneratedSequence>;
    WithForeignKey.FK1.Value := 10000;

    FManager.Insert([WithForeignKey]);

    WithForeignKey := CreateObject<TInsertTestWithForeignKey>;
    WithForeignKey.FK1 := CreateObject<TInsertAutoGeneratedSequence>;
    WithForeignKey.Value := 100;

    FManager.Insert([WithForeignKey]);

    WithForeignKey := CreateObject<TInsertTestWithForeignKey>;
    WithForeignKey.FK1 := CreateObject<TInsertAutoGeneratedSequence>;
    WithForeignKey.Value := 100;

    FManager.Insert([WithForeignKey]);

    WithForeignKey := CreateObject<TInsertTestWithForeignKey>;
    WithForeignKey.Value := 200;

    FManager.Insert([WithForeignKey]);

    WithForeignKey := CreateObject<TInsertTestWithForeignKey>;
    WithForeignKey.FK1 := CreateObject<TInsertAutoGeneratedSequence>;
    WithForeignKey.Value := 200;

    FManager.Insert([WithForeignKey]);

    var MyEntity := CreateObject<TMyEntity>;

    FManager.Insert([MyEntity]);

    LazyArrayClass := CreateObject<TLazyArrayClass>;
    LazyArrayClass.Id := 30;
    LazyArrayClass.LazyArray := [CreateObject<TLazyArrayClassChild>, CreateObject<TLazyArrayClassChild>];

    FManager.Insert([LazyArrayClass]);

    LazyArrayClass := CreateObject<TLazyArrayClass>;
    LazyArrayClass.Id := 10;
    LazyArrayClass.LazyArray := [CreateObject<TLazyArrayClassChild>, CreateObject<TLazyArrayClassChild>];

    FManager.Insert([LazyArrayClass]);

    var LazyClass := CreateObject<TLazyClass>;
    LazyClass.Id := 10;
    LazyClass.Lazy := MyEntity;

    FManager.Insert([LazyClass]);

    var LazyFieldChild := CreateObject<TLazyFilterChild>;
    LazyFieldChild.Field := 'Value';

    var LazyFilter := CreateObject<TLazyFilter>;
    LazyFilter.LazyField := LazyFieldChild;

    FManager.Insert([LazyFilter]);
  end;

begin
  FManager.Mapper.LoadAll;

  FManager.UpdateDatabaseSchema;

  FManager.ExectDirect(
    '''
      create table MyEntityWithoutEntityAttribute (Id int, Name varchar(150), Value numeric(15, 7));
    '''
    );

  InsertData;
end;

procedure TManagerTest.Setup;
begin
  FGarbage := TObjectList<TObject>.Create;
  FManager := TPersistoManager.Create(nil);

  FConnection := CreateConnection(FManager);
  FManager.Connection := CreateConnection(FManager);
  FManager.Manipulator := CreateDatabaseManipulator(FManager);

  FManager.CreateDatabase;

  PrepareDatabase;
end;

procedure TManagerTest.TearDown;
begin
  FConnection := nil;
  NullStrictConvert := True;

  FManager.DropDatabase;

  FGarbage.Free;

  FManager.Free;
end;

procedure TManagerTest.WhenAClassIsInheritedFromAnotherClassMustInsertTheParentClassInTheInsert;
begin
  var InheritedObject := CreateObject<TMyEntityInheritedFromSimpleClass>;
  InheritedObject.AnotherProperty := 'Value';
  InheritedObject.BaseProperty := 'Value';
  InheritedObject.Id := 20;

  FManager.Insert([InheritedObject]);

  var Cursor := FManager.OpenCursor('select count(*) from MyEntityInheritedFromSingle where Id = 20');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual(1, Cursor.GetDataSet.Fields[0].AsInteger);

  Cursor := FManager.OpenCursor('select count(*) from MyEntityInheritedFromSimpleClass where Id = 20');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual(1, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenChangeTheForeignKeyOfTheObjectMustUpdateTheForeignKeyValueFromTheCurrentTable;
begin
  var &Object1 := CreateObject<TClassWithForeignKey>;
  &Object1.Id := 20;
  var &Object2 := CreateObject<TClassWithPrimaryKey>;
  &Object2.Id := 35;

  FManager.Insert([&Object1]);

  FManager.Insert([&Object2]);

  &Object1.AnotherClass := &Object2;

  FManager.Update([&Object1]);

  var Cursor := FManager.OpenCursor('select IdAnotherClass from ClassWithForeignKey where Id = 20');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual(35, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenDeleteAnObjectMustRemoveOnlyThisObject;
begin
  var LazyArrayClass := CreateObject<TLazyArrayClass>;
  LazyArrayClass.Id := 1;

  FManager.Insert([LazyArrayClass]);

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Delete([LazyArrayClass]);
    end);

  var Objects := FManager.Select.All.From<TLazyArrayClass>.Open.All;

  Assert.AreEqual(2, Length(Objects));
end;

procedure TManagerTest.WhenDontFindTheFieldInTheOrderByClauseMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      FManager.Select.All.From<TClassWithPrimaryKey>.OrderBy.Field('WrongFieldName').Open.All;
    end, EFieldNotInCurrentSelection);
end;

procedure TManagerTest.WhenDontFindTheFieldInTheWhereClauseMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      FManager.Select.All.From<TClassWithPrimaryKey>.Where(Field('WrongFieldName') = 35).Open.All;
    end, EFieldNotInCurrentSelection);
end;

procedure TManagerTest.WhenFilterAComplexFieldFromAnInheritedTableMustReturnTheObjectAsExpected;
begin
  var Objects := FManager.Select.All.From<TManyValueParentInherited>.Where(Field('Childs.Value.Value') = 35).Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(35, Objects[0].Childs[0].Value.Value);
end;

procedure TManagerTest.WhenFilterAFieldMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Id') = 5).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(5, Objects[0].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithBetweenOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Id').Between(3, 8)).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(3, Length(Objects));
  Assert.AreEqual(3, Objects[0].Id);
  Assert.AreEqual(5, Objects[1].Id);
  Assert.AreEqual(8, Objects[2].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithComplexFieldNameInManyValueAssociationLinkMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TMyManyValue>.Where(Field('Childs.ManyValueAssociation.ManyValueAssociationList.Value') = 60).Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(60, Objects[0].Childs[0].ManyValueAssociation.ManyValueAssociationList[0].Value);
end;

procedure TManagerTest.WhenFilterAFieldWithComplexFieldNameMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TInsertTestWithForeignKey>.Where(Field('FK1.Value') = 30000).Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(30000, Objects[0].FK1.Value);
end;

procedure TManagerTest.WhenFilterAFieldWithGreaterThanOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Id') > 5).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(2, Length(Objects));
  Assert.AreEqual(8, Objects[0].Id);
  Assert.AreEqual(10, Objects[1].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithGreaterThanOrEqualOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Id') >= 5).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(3, Length(Objects));
  Assert.AreEqual(5, Objects[0].Id);
  Assert.AreEqual(8, Objects[1].Id);
  Assert.AreEqual(10, Objects[2].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithIsNullOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TClassWithNullableProperty>.Where(Field('Nullable').IsNull).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(1, Objects[0].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithLessThanOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Id') < 5).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(2, Length(Objects));
  Assert.AreEqual(1, Objects[0].Id);
  Assert.AreEqual(3, Objects[1].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithLessThanOrEqualOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Id') <= 5).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(3, Length(Objects));
  Assert.AreEqual(1, Objects[0].Id);
  Assert.AreEqual(3, Objects[1].Id);
  Assert.AreEqual(5, Objects[2].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithLikeOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Value').Like('B__')).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(2, Length(Objects));
  Assert.AreEqual(3, Objects[0].Id);
  Assert.AreEqual(8, Objects[1].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithLogicalNotOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TClassWithNullableProperty>.Where(not Field('Nullable').IsNull).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(2, Objects[0].Id);
end;

procedure TManagerTest.WhenFilterAFieldWithNotEqualOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(Field('Id') <> 5).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(4, Length(Objects));
  Assert.AreEqual(1, Objects[0].Id);
  Assert.AreEqual(3, Objects[1].Id);
  Assert.AreEqual(8, Objects[2].Id);
  Assert.AreEqual(10, Objects[3].Id);
end;

procedure TManagerTest.WhenFilterAInheritedFieldMustFilterByThisField;
begin
  var Objects := FManager.Select.All.From<TClassLevel4>.Where(Field('Field1') = 'abc').Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual('abc', Objects[0].Field1);
end;

procedure TManagerTest.WhenFilterWithBitwiseAndOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where((Field('Id') < 10) and (Field('Id') > 5)).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(8, Objects[0].Id);
end;

procedure TManagerTest.WhenFilterWithBitwiseOrOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where((Field('Id') = 10) or (Field('Id') = 5)).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(2, Length(Objects));
  Assert.AreEqual(5, Objects[0].Id);
  Assert.AreEqual(10, Objects[1].Id);
end;

procedure TManagerTest.WhenGetTheFieldValueFromALazyArrayMustReturnTheArrayInTheValueOfTheField;
begin
  var LazyClass := FManager.Select.All.From<TLazyArrayClass>.Where(Field('Id') = 10).Open.One;
  var Value: TValue;
  var Field := FManager.Mapper.GetTable(LazyClass.ClassType).Field['LazyArray'];

  Field.HasValue(LazyClass, Value);

  Assert.AreEqual(TypeInfo(TArray<TLazyArrayClassChild>), Value.TypeInfo);

  Assert.AreEqual(2, Value.ArrayLength);
end;

procedure TManagerTest.WhenInsertAClassThatIsRecursiveInItSelfCantRaiseErrorOfStackOverflow;
begin
  var &Object := CreateObject<TStackOverflowClass>;
  &Object.Callback := CreateObject<TStackOverflowClass>;
  &Object.Callback.CallBack := &Object;

  Assert.WillNotRaise(
    procedure
    begin
      try
        FManager.Insert([&Object]);
      except
        on E: ERecursionInsertionError do
          ;
      end;
    end);
end;

procedure TManagerTest.WhenInsertAManyValueAssociationClassWithALazyForeignKeyMustInsertTheChildObjectsWithTheLinkToTheParentClassFilled;
begin
  var LazyArrayClass := CreateObject<TLazyArrayClass>;
  LazyArrayClass.Id := 20;
  LazyArrayClass.LazyArray := [CreateObject<TLazyArrayClassChild>];

  FManager.Insert([LazyArrayClass]);

  var Cursor := FManager.OpenCursor('select IdLazyArrayClass from LazyArrayClassChild where IdLazyArrayClass = 20');

  Assert.IsTrue(Cursor.Next);

  Assert.AreEqual(20, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenInsertAnObjectMustStartAnTransactionAndIfRaiseAnErrorMustRollback;
begin
  var Objects := [TEntityWithError.Create, TEntityWithError.Create, TEntityWithError.Create];

  Objects[High(Objects)].Error := 20;

  Assert.WillRaise(
    procedure
    begin
      FManager.Insert(TArray<TObject>(Objects));
    end, Exception);

  var Cursor := FManager.OpenCursor('select count(*) from EntityWithError');

  Cursor.Next;

  Assert.AreEqual(0, Cursor.GetDataSet.Fields[0].AsInteger);

  Objects[0].Free;

  Objects[1].Free;

  Objects[2].Free;
end;

procedure TManagerTest.WhenInsertAnObjectMustUpdateTheForeignKeyValues;
begin
  var ForeignKeyObject := CreateObject<TInsertAutoGeneratedSequence>;
  ForeignKeyObject.Value := 1111;
  var MainObject := CreateObject<TInsertTestWithForeignKey>;

  FManager.Insert([ForeignKeyObject]);

  ForeignKeyObject.Value := 1234;
  MainObject.FK1 := ForeignKeyObject;

  FManager.Insert([MainObject]);

  var Cursor := FManager.OpenCursor('select Value from InsertAutoGeneratedSequence where Id = ''' + ForeignKeyObject.Id.ToString + '''');

  Cursor.Next;

  Assert.AreEqual(1234, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenInsertAnObjectTheObjectsMustBeProcessedOnlyOneTime;
begin
  var MainObject := CreateObject<TInsertTestWithForeignKey>;
  MainObject.FK1 := CreateObject<TInsertAutoGeneratedSequence>;
  MainObject.FK2 := MainObject.FK1;

  FManager.Insert([MainObject]);

  var Cursor := FManager.OpenCursor('select count(*) from InsertAutoGeneratedSequence where Id = ''' +  MainObject.FK1.Id.ToString + '''');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual(1, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenInsertAnObjectWithAutoGeneratedValuesMustLoadTheValueInTheInsertedObject;
begin
  var &Object := CreateObject<TInsertAutoGenerated>;

  FManager.Insert([&Object]);

  Assert.IsNotEmpty(&Object.Id);
  Assert.AreEqual(FormatDateTime('dd-mm-yyyy hh:nn', Now), FormatDateTime('dd-mm-yyyy hh:nn', &Object.DateTime));
end;

procedure TManagerTest.WhenInsertAnObjectWithEmptyForeignKeysCantRaiseAnyError;
begin
  var &Object := CreateObject<TClassWithForeignKey>;
  &Object.Id := 40;

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Insert([&Object]);
    end);
end;

procedure TManagerTest.WhenInsertAnObjectWithForeignKeyMustInsertTheForeignKeyPrimaryKeyValueInTheCurrentObject;
begin
  var &Object := CreateObject<TClassWithForeignKey>;
  &Object.Id := 30;
  &Object.AnotherClass := CreateObject<TClassWithPrimaryKey>;
  &Object.AnotherClass.Id := 45;

  FManager.Insert([&Object]);

  var Cursor := FManager.OpenCursor('select IdAnotherClass from ClassWithForeignKey where Id = 30');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual(45, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenInsertAnObjectWithManyValueAssociationCanRaiseAnyError;
begin
  var &Object := CreateObject<TMyEntityWithManyValueAssociation>;
  &Object.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>, CreateObject<TMyEntityWithManyValueAssociationChild>];

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Insert([&Object]);
    end);
end;

procedure TManagerTest.WhenInsertAnObjectWithManyValueAssociationMustInsertTheChildValues;
begin
  var &Object := CreateObject<TMyEntityWithManyValueAssociation>;
  &Object.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>, CreateObject<TMyEntityWithManyValueAssociationChild>];

  FManager.Insert([&Object]);

  var Cursor := FManager.OpenCursor('select count(*) from MyEntityWithManyValueAssociationChild where IdManyValueAssociation = ''' + &Object.Id + '''');

  Cursor.Next;

  Assert.AreEqual(2, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenInsertAnObjectWithManyValueAssociationMustUpdateTheParentForeignKeyValueInTheChildTable;
begin
  var &Object := CreateObject<TMyEntityWithManyValueAssociation>;
  &Object.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>];

  FManager.Insert([&Object]);

  var Cursor := FManager.OpenCursor('select IdManyValueAssociation from MyEntityWithManyValueAssociationChild');

  Cursor.Next;

  Assert.IsNotEmpty(Cursor.GetDataSet.Fields[0].AsString);
end;

procedure TManagerTest.WhenInsertAnObjectWithRecursionAndTheForeignKeyIsntRequiredMustDelayTheInsertionOfForeignKeyToGetTheKeyInsertedAndUpdateTheColumnValue;
begin
  var &Object := CreateObject<TStackOverflowClass>;
  &Object.Callback := &Object;

  FManager.Insert([&Object]);

  var Cursor := FManager.OpenCursor('select Id, IdCallBack from StackOverflowClass where Id = ''' + &Object.Id + '''');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual(Cursor.GetDataSet.Fields[0].AsString, Cursor.GetDataSet.Fields[1].AsString);
end;

procedure TManagerTest.WhenInsertARecursiveRequiredObjectMustInsertTheForeignKeyFirstToInsertTheMainObject;
begin
  var &Object := CreateObject<TClassRecursiveFirst>;
  &Object.Id := 20;
  &Object.GoingThird := CreateObject<TClassRecursiveThird>;
  &Object.GoingThird.Id := 20;
  &Object.GoingThird.GoingSecond := CreateObject<TClassRecursiveSecond>;
  &Object.GoingThird.GoingSecond.Id := 20;
  &Object.GoingThird.GoingSecond.GoingFirst := &Object;

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Insert([&Object]);
    end);

  var Cursor := FManager.OpenCursor('select IdGoingSecond from ClassRecursiveThird where Id = 20');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual(20, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenInsertAValueInManagerMustInsertTheValueInDatabaseAsExpected;
begin
  var &Object := CreateObject<TInsertTest>;
  &Object.Id := 'abc';
  &Object.IntegerValue := 123;
  &Object.Value := 123.456;

  FManager.Insert([&Object]);

  var Cursor := FManager.OpenCursor('select * from InsertTest');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual('abc', Cursor.GetDataSet.Fields[0].AsString);
  Assert.AreEqual('123', Cursor.GetDataSet.Fields[1].AsString);
  Assert.AreEqual('123.456', FormatFloat('0.000', Cursor.GetDataSet.Fields[2].AsFloat, TFormatSettings.Invariant));
end;

procedure TManagerTest.WhenInsertingAnUnloadedLazyFieldMustInsertTheKeyValueFromLazyField;
begin
  var MyClass := TLazyClass.Create;
  MyClass.Id := 41;
  var Table := FManager.Mapper.GetTable(MyClass.ClassType);

  Table.Field['Lazy'].LazyValue[MyClass] := TLazyLoader.Create(nil, nil, 100, nil);

  FManager.Insert([MyClass]);

  var Cursor := FManager.OpenCursor('select * from LazyClass where Id = 41');

  Cursor.Next;

  Assert.AreEqual(100, Cursor.GetDataSet.FieldByName('IdLazy').AsInteger);

  MyClass.Free;
end;

procedure TManagerTest.WhenInsertMustInsertAllTheObjectsInTheArray;
begin
  var Object1 := TInsertAutoGenerated.Create;
  var Object2 := TAutoGeneratedClass.Create;
  var Object3 := TInsertTestWithForeignKeyMoreOne.Create;

  FManager.Insert([Object1, Object2, Object3]);

  Assert.IsNotEmpty(Object1.Id);

  Assert.IsNotEmpty(Object2.Id);

  Assert.IsNotEmpty(Object3.Id);

  Object1.Free;

  Object2.Free;

  Object3.Free;
end;

procedure TManagerTest.WhenLoadALazyManyValueAssociationMustLoadAllChildsAsExpected;
begin
  var LazyClass := FManager.Select.All.From<TLazyArrayClass>.Where(Field('Id') = 10).Open.One;

  Assert.AreEqual(2, Length(LazyClass.LazyArray.Value));
end;

procedure TManagerTest.WhenLoadALazyManyValueAssociationTheLoadOfChildObjectsMustBeDelayed;
begin
  var LazyClass := FManager.Select.All.From<TLazyArrayClass>.Where(Field('Id') = 30).Open.One;

  FManager.ExectDirect('delete from LazyArrayClassChild where IdLazyArrayClass = 30');

  Assert.AreEqual(0, Length(LazyClass.LazyArray.Value));
end;

procedure TManagerTest.WhenLoadAnObjectWithOrderByMustLoadTheObjectsInTheOrderAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.OrderBy.Field('Id', False).Open.All;

  Assert.AreEqual(10, Objects[0].Id);
  Assert.AreEqual(8, Objects[1].Id);
  Assert.AreEqual(5, Objects[2].Id);
  Assert.AreEqual(3, Objects[3].Id);
  Assert.AreEqual(1, Objects[4].Id);
end;

procedure TManagerTest.WhenMixBitwiseOrAndTheBitwiseAndOperatorMustReturnTheObjectsInTheFilterAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.Where(((Field('Id') = 10) or (Field('Id') = 3)) and (Field('Id') < 5)).OrderBy.Field('Id').Open.All;

  Assert.AreEqual(1, Length(Objects));
  Assert.AreEqual(3, Objects[0].Id);
end;

procedure TManagerTest.WhenRemoveAnObjectMustDeleteTheRecordFromDatabase;
begin
  var Objects := FManager.Select.All.From<TLazyArrayClassChild>.Open.All;

  FManager.Delete(TArray<TObject>(Objects));

  Objects := FManager.Select.All.From<TLazyArrayClassChild>.Open.All;

  Assert.AreEqual(0, Length(Objects));
end;

procedure TManagerTest.WhenRemoveAnObjectMustStartATransaction;
begin
  var LazyArrayClass := CreateObject<TLazyArrayClass>;
  LazyArrayClass.Id := 1;

  FManager.Insert([LazyArrayClass]);

  var Objects := FManager.Select.All.From<TLazyArrayClass>.OrderBy.Field('Id').Open.All;

  Assert.WillRaise(
    procedure
    begin
      FManager.Delete(TArray<TObject>(Objects));
    end, Exception);

  Objects := FManager.Select.All.From<TLazyArrayClass>.Open.All;

  Assert.AreEqual(3, Length(Objects));
end;

procedure TManagerTest.WhenSaveAnObjectMoreThenOnceItMustBeSavedOnlyOnceInTheDatabase;
begin
  var AnotherManager := TPersistoManager.Create(nil);
  AnotherManager.Connection := FConnection;
  AnotherManager.Manipulator := CreateDatabaseManipulator(AnotherManager);
  var MyEntity := CreateObject<TAutoGeneratedClass>;
  MyEntity.Value := 'abc';

  FManager.Save([MyEntity]);

  AnotherManager.Save([MyEntity]);

  Assert.AreEqual(1, Length(AnotherManager.Select.All.From<TAutoGeneratedClass>.Open.All));

  AnotherManager.Free;
end;

procedure TManagerTest.WhenSaveAnObjectMustStartAnTransactionAndIfIsRaisedAnErrorMustRollback;
begin
  var Objects := [TEntityWithError.Create, TEntityWithError.Create, TEntityWithError.Create];

  Objects[High(Objects)].Error := 20;

  Assert.WillRaise(
    procedure
    begin
      FManager.Save(TArray<TObject>(Objects));
    end, Exception);

  var Cursor := FManager.OpenCursor('select count(*) from EntityWithError');

  Cursor.Next;

  Assert.AreEqual(0, Cursor.GetDataSet.Fields[0].AsInteger);

  Objects[0].Free;

  Objects[1].Free;

  Objects[2].Free;
end;

procedure TManagerTest.WhenSaveAnObjectThatAlreadyInTheDatabaseMustUpdateTheFieldsOfTheObject;
begin
  var &Object := CreateObject<TInsertAutoGenerated>;

  FManager.Insert([&Object]);

  &Object.Value := 1234;

  FManager.Save([&Object]);

  var Cursor := FManager.OpenCursor('select Value from InsertAutoGenerated where Id = ''' + &Object.Id + '''');

  Cursor.Next;

  Assert.AreEqual(1234, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenSaveAnObjectThatDontExistsInDatabaseCantRaiseForiegnObjectException;
begin
  var MyEntity := CreateObject<TMyEntityWithoutEntityAttribute>;
  MyEntity.Id := 100;
  MyEntity.Name := 'abc';
  MyEntity.Value := 111;

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Save([MyEntity]);
    end);
end;

procedure TManagerTest.WhenSaveAnObjectThatDontExistsInDatabaseMustInsertThisObject;
begin
  var MyEntity := CreateObject<TMyEntityWithoutEntityAttribute>;
  MyEntity.Id := 200;
  MyEntity.Name := 'abc';
  MyEntity.Value := 111;

  FManager.Save([MyEntity]);

  var Cursor := FManager.OpenCursor('select Id from MyEntityWithoutEntityAttribute where Id = 200');

  Cursor.Next;

  Assert.AreEqual(200, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenSaveAnObjectThatWasntInsertedMustInsertTheObject;
begin
  var &Object := CreateObject<TInsertAutoGenerated>;

  FManager.Save([&Object]);

  var Cursor := FManager.OpenCursor('select count(*) from InsertAutoGenerated where Id = ''' + &Object.Id + '''');

  Cursor.Next;

  Assert.AreEqual(1, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenSaveMustSaveAllTheObjectsInTheList;
begin
  var Object1 := TInsertAutoGenerated.Create;
  var Object2 := TAutoGeneratedClass.Create;
  var Object3 := TInsertTestWithForeignKeyMoreOne.Create;

  FManager.Save([Object1, Object2, Object3]);

  Assert.IsNotEmpty(Object1.Id);

  Assert.IsNotEmpty(Object2.Id);

  Assert.IsNotEmpty(Object3.Id);

  Object1.Free;

  Object2.Free;

  Object3.Free;
end;

procedure TManagerTest.WhenSelectAnObjectUsingAForeignKeyFieldMustFindAndFilterTheTableByThisField;
begin
  var Open := FManager.Select.All.From<TInsertTestWithForeignKey>.Where(Field('FK1').IsNull and (Field('Value') = 200)).Open;
  var Result: TArray<TInsertTestWithForeignKey>;

  Assert.WillNotRaise(
    procedure
    begin
      Result := Open.All;
    end);

  Assert.AreEqual(1, Length(Result));
end;

procedure TManagerTest.WhenTheOrderByClauseAsAnForeignKeyObjectTheOrderByMustBeOrderAsExpected;
begin
  var Open := FManager.Select.All.From<TInsertTestWithForeignKey>.Where(Field('Value') = 100).OrderBy.Field('FK1').Open;
  var Result: TArray<TInsertTestWithForeignKey>;

  Assert.WillNotRaise(
    procedure
    begin
      Result := Open.All;
    end);

  Assert.IsTrue(Result[0].FK1.Id < Result[1].FK1.Id);
end;

procedure TManagerTest.WhenTheOrderByClauseHasAComplexFieldNameMustFindTheFieldAndApplyInTheOrderByList;
begin
  var Objects := FManager.Select.All.From<TInsertTestWithForeignKey>.Where(Field('FK1.Value') >= 10000).OrderBy.Field('FK1.Value').Open.All;

  Assert.AreEqual(10000, Objects[0].FK1.Value);
  Assert.AreEqual(20000, Objects[1].FK1.Value);
  Assert.AreEqual(30000, Objects[2].FK1.Value);
end;

procedure TManagerTest.WhenTheOrderByHasMoreThenOneFieldMustExecuteAsExpected;
begin
  var Objects := FManager.Select.All.From<TAAAA>.OrderBy.Field('Value').Field('Id', False).Open.All;

  Assert.AreEqual(10, Objects[0].Id);
  Assert.AreEqual('AAA', Objects[0].Value);
  Assert.AreEqual(5, Objects[1].Id);
  Assert.AreEqual('AAA', Objects[1].Value);
  Assert.AreEqual(1, Objects[2].Id);
  Assert.AreEqual('AAA', Objects[2].Value);
  Assert.AreEqual(8, Objects[3].Id);
  Assert.AreEqual('BBB', Objects[3].Value);
  Assert.AreEqual(3, Objects[4].Id);
  Assert.AreEqual('BBB', Objects[4].Value);
end;

procedure TManagerTest.WhenTryToUpdateAForeignObjectMustRaiseErrorExplainingThisNotAllowed;
begin
  var &Object := CreateObject<TInsertTest>;
  &Object.Id := 'ccc';

  Assert.WillRaise(
    procedure
    begin
      FManager.Update([&Object]);
    end, EForeignObjectNotAllowed);
end;

procedure TManagerTest.WhenUpdateAClassThatIsRecursiveInItSelfCantRaiseErrorOfStackOverflow;
begin
  var &Object := CreateObject<TStackOverflowClass>;

  FManager.Insert([&Object]);

  Assert.WillNotRaise(
    procedure
    begin
      &Object.Callback := CreateObject<TStackOverflowClass>;
      &Object.Callback.CallBack := &Object;

      try
        FManager.Update([&Object]);
      except
        on E: ERecursionInsertionError do
          ;
      end;
    end);
end;

procedure TManagerTest.WhenUpdateALazyClassCantRaiseAnyError;
begin
  var LazyClass := FManager.Select.All.From<TLazyClass>.Where(Field('Id') = 10).Open.One;

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Update([LazyClass]);
    end);
end;

procedure TManagerTest.WhenUpdateAnInheritedObjectMustUpdateAllClassLevelsToo;
begin
  var InheritedObject := CreateObject<TMyEntityInheritedFromSimpleClass>;
  InheritedObject.AnotherProperty := 'aaa';
  InheritedObject.BaseProperty := 'aaa';
  InheritedObject.Id := 10;
  InheritedObject.SimpleProperty := 111;

  FManager.Insert([InheritedObject]);

  InheritedObject.AnotherProperty := 'bbb';
  InheritedObject.BaseProperty := 'bbb';
  InheritedObject.SimpleProperty := 222;

  FManager.Update([InheritedObject]);

  var Cursor := FManager.OpenCursor('select AnotherProperty, BaseProperty from MyEntityInheritedFromSingle where Id = 10');

  Cursor.Next;

  Assert.AreEqual('bbb', Cursor.GetDataSet.Fields[0].AsString);
  Assert.AreEqual('bbb', Cursor.GetDataSet.Fields[1].AsString);

  Cursor := FManager.OpenCursor('select SimpleProperty from MyEntityInheritedFromSimpleClass where Id = 10');

  Cursor.Next;

  Assert.AreEqual(222, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenUpdateAnObjectMustInsertTheNewObjectInTheForeignKey;
begin
  var ForeignKeyObject := CreateObject<TInsertAutoGeneratedSequence>;
  var MainObject := CreateObject<TInsertTestWithForeignKey>;

  FManager.Insert([MainObject]);

  MainObject.FK1 := ForeignKeyObject;

  FManager.Update([MainObject]);

  var Cursor := FManager.OpenCursor('select count(*) from InsertAutoGeneratedSequence where Id = ''' + ForeignKeyObject.Id.ToString + '''');

  Cursor.Next;

  Assert.AreEqual(1, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenUpdateAnObjectMustStartAnTransactionAndIfRaiseAnErrorMustRollback;
begin
  var Objects := [TEntityWithError.Create, TEntityWithError.Create, TEntityWithError.Create];

  FManager.Insert(TArray<TObject>(Objects));

  Objects[0].Error := 5;
  Objects[1].Error := 10;
  Objects[2].Error := 20;

  Assert.WillRaise(
    procedure
    begin
      FManager.Update(TArray<TObject>(Objects));
    end, Exception);

  var Cursor := FManager.OpenCursor('select count(*) from EntityWithError where Error > 0');

  Cursor.Next;

  Assert.AreEqual(0, Cursor.GetDataSet.Fields[0].AsInteger);

  Objects[0].Free;

  Objects[1].Free;

  Objects[2].Free;
end;

procedure TManagerTest.WhenUpdateAnObjectMustUpdateOnlyTheChangedFieldsOfTheObject;
begin
  var Manager := TPersistoManager.Create(nil);
  var DatabaseConnection := TDatabaseConnectionMock.Create(CreateConnection(Manager));
  Manager.Connection := DatabaseConnection;
  Manager.Manipulator := CreateDatabaseManipulator(Manager);
  var &Object := CreateObject<TInsertTest>;
  &Object.Id := 'ddd';
  &Object.IntegerValue := 111;
  &Object.Value := 111;

  Manager.Insert([&Object]);

  &Object.IntegerValue := 3;

  Manager.Update([&Object]);

  Assert.AreEqual('update InsertTest set IntegerValue=:IntegerValue where Id=:Id', DatabaseConnection.LastCommandExecuted);

  Manager.Free;
end;

procedure TManagerTest.WhenUpdateAnObjectMustUpdateOnlyTheObjectCallInTheProcedure;
begin
  var Object1 := CreateObject<TInsertTest>;
  Object1.Id := 'aaa';
  Object1.IntegerValue := 111;
  Object1.Value := 111;
  var Object2 := CreateObject<TInsertTest>;
  Object2.Id := 'bbb';
  Object2.IntegerValue := 111;
  Object2.Value := 111;

  FManager.Insert([Object1]);

  FManager.Insert([Object2]);

  Object2.IntegerValue := 222;
  Object2.Value := 222.333;

  FManager.Update([Object2]);

  var Cursor := FManager.OpenCursor('select IntegerValue, Value from InsertTest where Id = ''aaa''');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual('111', Cursor.GetDataSet.Fields[0].AsString);
  Assert.AreEqual('111.000', FormatFloat('0.000', Cursor.GetDataSet.Fields[1].AsFloat, TFormatSettings.Invariant));
end;

procedure TManagerTest.WhenUpdateAnObjectMustUpdateTheChangedFieldsOfTheObject;
begin
  var &Object := CreateObject<TInsertTest>;
  &Object.Id := 'eee';
  &Object.IntegerValue := 111;
  &Object.Value := 111;

  FManager.Insert([&Object]);

  &Object.IntegerValue := 222;
  &Object.Value := 222.333;

  FManager.Update([&Object]);

  var Cursor := FManager.OpenCursor('select IntegerValue, Value from InsertTest where Id = ''eee''');

  Assert.IsTrue(Cursor.Next);
  Assert.AreEqual('222', Cursor.GetDataSet.Fields[0].AsString);
  Assert.AreEqual('222.333', FormatFloat('0.000', Cursor.GetDataSet.Fields[1].AsFloat, TFormatSettings.Invariant));
end;

procedure TManagerTest.WhenUpdateAnObjectMustUpdateTheForeignKeyOfTheObjectToo;
begin
  var MainObject := CreateObject<TInsertTestWithForeignKey>;
  MainObject.FK1 := CreateObject<TInsertAutoGeneratedSequence>;

  FManager.Insert([MainObject]);

  MainObject.FK1.Value := 123;

  FManager.Update([MainObject]);

  var Cursor := FManager.OpenCursor('select Value from InsertAutoGeneratedSequence where Id = ''' + MainObject.FK1.Id.ToString + '''');

  Cursor.Next;

  Assert.AreEqual(123, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenUpdateAnObjectThatDontExistsInDatabaseMustRaiseForeignObjectException;
begin
  var MyEntity := CreateObject<TMyEntityWithoutEntityAttribute>;
  MyEntity.Id := 300;
  MyEntity.Name := 'abc';
  MyEntity.Value := 111;

  Assert.WillRaise(
    procedure
    begin
      FManager.Update([MyEntity]);
    end, EForeignObjectNotAllowed);
end;

procedure TManagerTest.WhenUpdateAnObjectThatExistsInDatabaseAndHaveManyValueAssociationCantRaiseDatabaseError;
begin
  var MyEntity := CreateObject<TManyValueParentInherited>;
  MyEntity.Id := 10;

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Update([MyEntity]);
    end);
end;

procedure TManagerTest.WhenUpdateAnObjectThatExistsInDatabaseCantRaiseForeignObjectException;
begin
  var MyEntity := CreateObject<TMyEntityWithoutEntityAttribute>;
  MyEntity.Id := 20;
  MyEntity.Name := 'abc';
  MyEntity.Value := 111;

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Update([MyEntity]);
    end);
end;

procedure TManagerTest.WhenUpdateAnObjectThatExistsInDatabaseMustLoadTheObjectStatusAndUpdateTheValuesInDatabase;
begin
  var MyEntity := CreateObject<TMyEntityWithoutEntityAttribute>;
  MyEntity.Id := 20;
  MyEntity.Name := 'Name Field';
  MyEntity.Value := 8888;

  FManager.Update([MyEntity]);

  var Cursor := FManager.OpenCursor('select * from MyEntityWithoutEntityAttribute where Id = 20');

  Cursor.Next;

  Assert.AreEqual('Name Field', Cursor.GetDataSet.FieldByName('Name').AsString);
  Assert.AreEqual(8888, Cursor.GetDataSet.FieldByName('Value').AsInteger);
end;

procedure TManagerTest.WhenUpdateAnObjectWithManyValueAssociationCantRaiseAnyError;
begin
  var &Object := CreateObject<TMyEntityWithManyValueAssociation>;
  &Object.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>, CreateObject<TMyEntityWithManyValueAssociationChild>];

  FManager.Insert([&Object]);

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Update([&Object]);
    end);
end;

procedure TManagerTest.WhenUpdateAnObjectWithManyValueAssociationMustInsertTheNewChildValues;
begin
  var &Object := CreateObject<TMyEntityWithManyValueAssociation>;

  FManager.Insert([&Object]);

  &Object.ManyValueAssociationList := [CreateObject<TMyEntityWithManyValueAssociationChild>];

  FManager.Update([&Object]);

  var Cursor := FManager.OpenCursor('select count(*) from MyEntityWithManyValueAssociationChild where Id = ''' + &Object.ManyValueAssociationList[0].Id + '''');

  Cursor.Next;

  Assert.AreEqual(1, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenUpdateAnObjectWithManyValueAssociationMustUpdateTheChildValues;
begin
  var ChildObject := CreateObject<TMyEntityWithManyValueAssociationChild>;
  var &Object := CreateObject<TMyEntityWithManyValueAssociation>;
  &Object.ManyValueAssociationList := [ChildObject];

  FManager.Insert([&Object]);

  ChildObject.Value := 1234;

  FManager.Update([&Object]);

  var Cursor := FManager.OpenCursor('select Value from MyEntityWithManyValueAssociationChild where Id = ''' + ChildObject.Id + '''');

  Cursor.Next;

  Assert.AreEqual(1234, Cursor.GetDataSet.Fields[0].AsInteger);
end;

procedure TManagerTest.WhenUpdateAnObjectWithoutChangesCanRaiseAnyUpdateError;
begin
  var InheritedObject := CreateObject<TMyEntityInheritedFromSimpleClass>;
  InheritedObject.AnotherProperty := 'Value';
  InheritedObject.BaseProperty := 'Value';

  FManager.Insert([InheritedObject]);

  Assert.WillNotRaise(
    procedure
    begin
      FManager.Update([InheritedObject]);
    end);
end;

procedure TManagerTest.WhenUpdateMustUpdateAllTheObjectsInTheArray;
begin
  var Object1 := TInsertAutoGenerated.Create;
  var Object2 := TAutoGeneratedClass.Create;
  var Object3 := TInsertTestWithForeignKeyMoreOne.Create;

  FManager.Save([Object1, Object2, Object3]);

  Object1.Value := 25;
  Object2.Value := 'abc';
  Object3.FK := TInsertTestWithForeignKey.Create;

  FManager.Update([Object1, Object2, Object3]);

  var Cursor := FManager.OpenCursor(Format('select Value from InsertAutoGenerated where Id = ''%s''', [Object1.Id]));

  Cursor.Next;

  Assert.AreEqual(25, Cursor.GetDataSet.Fields[0].AsInteger);

  Cursor := FManager.OpenCursor(Format('select Value from AutoGeneratedClass where Id = ''%s''', [Object2.Id]));

  Cursor.Next;

  Assert.AreEqual('abc', Cursor.GetDataSet.Fields[0].AsString);

  Cursor := FManager.OpenCursor(Format('select * from InsertTestWithForeignKeyMoreOne where Id = ''%s'' and IdFK is not null', [Object3.Id]));

  Assert.IsTrue(Cursor.Next);

  Object1.Free;

  Object2.Free;

  Object3.FK.Free;

  Object3.Free;
end;

procedure TManagerTest.WhenUpdatintAnUnloadedLazyFieldMustUpdateTheKeyValueFromLazyField;
begin
  var MyClass := TLazyClass.Create;
  MyClass.Id := 41;
  var Table := FManager.Mapper.GetTable(MyClass.ClassType);

  FManager.Insert([MyClass]);

  Table.Field['Lazy'].LazyValue[MyClass] := TLazyLoader.Create(nil, nil, 100, nil);

  FManager.Update([MyClass]);

  var Cursor := FManager.OpenCursor('select * from LazyClass where Id = 41');

  Cursor.Next;

  Assert.AreEqual(100, Cursor.GetDataSet.FieldByName('IdLazy').AsInteger);

  MyClass.Free;
end;

procedure TManagerTest.WhenUseALazyFieldInTheFieldMustLoadTheJoinForTheFilterWorks;
begin
  var Value := FManager.Select.All.From<TLazyFilter>.Where(Field('LazyField.Field') = 'Value').Open.One;

  Assert.IsNotNil(Value);
end;

{ TManagerDatabaseManipulationTest }

procedure TManagerDatabaseManipulationTest.Setup;
begin
  FManager := TPersistoManager.Create(nil);
  FManager.Connection := CreateConnection(FManager);
  FManager.Manipulator := CreateDatabaseManipulator(FManager);

  FManager.CreateDatabase;

  FManager.Mapper.GetTable(TMySQLiteTable);
end;

procedure TManagerDatabaseManipulationTest.TearDown;
begin
  FManager.DropDatabase;

  FManager.Free;
end;

procedure TManagerDatabaseManipulationTest.WhenUpdateTheDatabaseCantRaiseAnyError;
begin
  Assert.WillNotRaise(FManager.UpdateDatabaseSchema);
end;

procedure TManagerDatabaseManipulationTest.WhenUpdateTheDatabaseMustCreateTheTablesAfterTheProcessEnd;
begin
  FManager.UpdateDatabaseSchema;

  Assert.WillNotRaise(
    procedure
    begin
      FManager.OpenCursor('select * from MySQLiteTable').Next;
    end);
end;

{ TDatabaseConnectionMock }

constructor TDatabaseConnectionMock.Create(const Connection: IDatabaseConnection);
begin
  inherited Create;

  FConnection := Connection;
end;

procedure TDatabaseConnectionMock.ExecuteDirect(const SQL: String);
begin
  LastCommandExecuted := SQL;

  FConnection.ExecuteDirect(SQL);
end;

procedure TDatabaseConnectionMock.ExecuteScript(const Script: String);
begin
  LastCommandExecuted := Script;

  FConnection.ExecuteScript(Script);
end;

function TDatabaseConnectionMock.GetDatabaseName: String;
begin
  Result := FConnection.DatabaseName;
end;

function TDatabaseConnectionMock.OpenCursor(const SQL: String): IDatabaseCursor;
begin
  LastCommandExecuted := SQL;

  Result := FConnection.OpenCursor(SQL);
end;

function TDatabaseConnectionMock.PrepareCursor(const SQL: String; const Params: TParams): IDatabaseCursor;
begin
  LastCommandExecuted := SQL;

  Result := FConnection.PrepareCursor(SQL, Params);
end;

procedure TDatabaseConnectionMock.SetDatabaseName(const Value: String);
begin

end;

function TDatabaseConnectionMock.StartTransaction: TDatabaseTransaction;
begin
  Result := FConnection.StartTransaction;
end;

end.

